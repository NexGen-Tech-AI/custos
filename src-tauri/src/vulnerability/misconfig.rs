// Misconfiguration Scanner - Detects security misconfigurations
// Checks firewall, encryption, weak passwords, exposed services, etc.

use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use std::process::Command;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Misconfiguration {
    pub id: String,
    pub category: MisconfigCategory,
    pub title: String,
    pub description: String,
    pub severity: MisconfigSeverity,
    pub affected_component: String,
    pub discovered_at: DateTime<Utc>,
    pub remediation_steps: Vec<String>,
    pub status: MisconfigStatus,
    pub cis_benchmark_ref: Option<String>,       // CIS Benchmark reference
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum MisconfigCategory {
    Firewall,
    Encryption,
    Authentication,
    Services,
    Permissions,
    Auditing,
    Updates,
    Network,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum MisconfigSeverity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum MisconfigStatus {
    New,
    Acknowledged,
    InRemediation,
    Resolved,
    Accepted,
}

pub struct MisconfigurationScanner {
    enabled: bool,
}

impl MisconfigurationScanner {
    pub fn new() -> Self {
        Self { enabled: true }
    }

    /// Run comprehensive security configuration scan
    pub fn scan(&self) -> Vec<Misconfiguration> {
        if !self.enabled {
            return Vec::new();
        }

        let mut findings = Vec::new();

        // Platform-specific checks
        #[cfg(target_os = "linux")]
        {
            findings.extend(self.check_linux_firewall());
            findings.extend(self.check_disk_encryption());
            findings.extend(self.check_ssh_config());
            findings.extend(self.check_exposed_services());
            findings.extend(self.check_user_accounts());
            findings.extend(self.check_file_permissions());
            findings.extend(self.check_auditd());
        }

        #[cfg(target_os = "windows")]
        {
            findings.extend(self.check_windows_firewall());
            findings.extend(self.check_bitlocker());
            findings.extend(self.check_windows_defender());
            findings.extend(self.check_windows_updates());
            findings.extend(self.check_user_account_control());
        }

        findings
    }

    // ===== Linux Checks =====

    #[cfg(target_os = "linux")]
    fn check_linux_firewall(&self) -> Vec<Misconfiguration> {
        let mut findings = Vec::new();

        // Check if ufw is active
        if let Ok(output) = Command::new("ufw").arg("status").output() {
            let status = String::from_utf8_lossy(&output.stdout);
            if !status.contains("Status: active") {
                findings.push(Misconfiguration {
                    id: "MISCONFIG-FW-001".to_string(),
                    category: MisconfigCategory::Firewall,
                    title: "Firewall disabled".to_string(),
                    description: "UFW firewall is not active. System is exposed to all incoming connections.".to_string(),
                    severity: MisconfigSeverity::High,
                    affected_component: "ufw".to_string(),
                    discovered_at: Utc::now(),
                    remediation_steps: vec![
                        "sudo ufw enable".to_string(),
                        "sudo ufw default deny incoming".to_string(),
                        "sudo ufw default allow outgoing".to_string(),
                    ],
                    status: MisconfigStatus::New,
                    cis_benchmark_ref: Some("CIS Ubuntu 22.04 LTS - 3.5.1.1".to_string()),
                });
            }
        } else {
            // Check iptables if ufw not available
            if let Ok(output) = Command::new("iptables").args(&["-L", "-n"]).output() {
                let rules = String::from_utf8_lossy(&output.stdout);
                // Check if there are any DROP or REJECT rules
                if !rules.contains("DROP") && !rules.contains("REJECT") {
                    findings.push(Misconfiguration {
                        id: "MISCONFIG-FW-002".to_string(),
                        category: MisconfigCategory::Firewall,
                        title: "No firewall rules configured".to_string(),
                        description: "iptables has no DROP or REJECT rules. All traffic is allowed.".to_string(),
                        severity: MisconfigSeverity::High,
                        affected_component: "iptables".to_string(),
                        discovered_at: Utc::now(),
                        remediation_steps: vec![
                            "Configure iptables rules or install ufw".to_string(),
                            "Example: sudo iptables -A INPUT -i lo -j ACCEPT".to_string(),
                        ],
                        status: MisconfigStatus::New,
                        cis_benchmark_ref: Some("CIS Ubuntu 22.04 LTS - 3.5".to_string()),
                    });
                }
            }
        }

        findings
    }

    #[cfg(target_os = "linux")]
    fn check_disk_encryption(&self) -> Vec<Misconfiguration> {
        let mut findings = Vec::new();

        // Check for LUKS encrypted volumes
        if let Ok(output) = Command::new("lsblk").args(&["-o", "NAME,TYPE,FSTYPE"]).output() {
            let output_str = String::from_utf8_lossy(&output.stdout);

            // Check if any disk uses LUKS encryption
            if !output_str.contains("crypto_LUKS") {
                findings.push(Misconfiguration {
                    id: "MISCONFIG-ENC-001".to_string(),
                    category: MisconfigCategory::Encryption,
                    title: "Disk encryption not enabled".to_string(),
                    description: "No LUKS encrypted volumes detected. Data at rest is not encrypted.".to_string(),
                    severity: MisconfigSeverity::Medium,
                    affected_component: "disk".to_string(),
                    discovered_at: Utc::now(),
                    remediation_steps: vec![
                        "Enable full disk encryption during OS installation".to_string(),
                        "Or encrypt data partitions with: cryptsetup luksFormat /dev/sdX".to_string(),
                    ],
                    status: MisconfigStatus::New,
                    cis_benchmark_ref: Some("CIS Ubuntu 22.04 LTS - 1.1.23".to_string()),
                });
            }
        }

        findings
    }

    #[cfg(target_os = "linux")]
    fn check_ssh_config(&self) -> Vec<Misconfiguration> {
        let mut findings = Vec::new();

        // Check SSH configuration
        if let Ok(config) = std::fs::read_to_string("/etc/ssh/sshd_config") {
            // Check for root login
            if config.contains("PermitRootLogin yes") {
                findings.push(Misconfiguration {
                    id: "MISCONFIG-SSH-001".to_string(),
                    category: MisconfigCategory::Authentication,
                    title: "SSH root login enabled".to_string(),
                    description: "SSH allows direct root login, increasing brute-force attack risk.".to_string(),
                    severity: MisconfigSeverity::High,
                    affected_component: "sshd".to_string(),
                    discovered_at: Utc::now(),
                    remediation_steps: vec![
                        "Edit /etc/ssh/sshd_config".to_string(),
                        "Set: PermitRootLogin no".to_string(),
                        "Restart SSH: sudo systemctl restart ssh".to_string(),
                    ],
                    status: MisconfigStatus::New,
                    cis_benchmark_ref: Some("CIS Ubuntu 22.04 LTS - 5.2.7".to_string()),
                });
            }

            // Check for password authentication
            if !config.contains("PasswordAuthentication no") {
                findings.push(Misconfiguration {
                    id: "MISCONFIG-SSH-002".to_string(),
                    category: MisconfigCategory::Authentication,
                    title: "SSH password authentication enabled".to_string(),
                    description: "SSH allows password authentication instead of key-only authentication.".to_string(),
                    severity: MisconfigSeverity::Medium,
                    affected_component: "sshd".to_string(),
                    discovered_at: Utc::now(),
                    remediation_steps: vec![
                        "Set up SSH key authentication first".to_string(),
                        "Edit /etc/ssh/sshd_config".to_string(),
                        "Set: PasswordAuthentication no".to_string(),
                    ],
                    status: MisconfigStatus::New,
                    cis_benchmark_ref: Some("CIS Ubuntu 22.04 LTS - 5.2.10".to_string()),
                });
            }
        }

        findings
    }

    #[cfg(target_os = "linux")]
    fn check_exposed_services(&self) -> Vec<Misconfiguration> {
        let mut findings = Vec::new();

        // Check for services listening on 0.0.0.0 (all interfaces)
        if let Ok(output) = Command::new("ss")
            .args(&["-tulpn"])
            .output()
        {
            let listeners = String::from_utf8_lossy(&output.stdout);

            // Check for dangerous services on 0.0.0.0
            if listeners.contains("0.0.0.0:3306") {
                findings.push(Misconfiguration {
                    id: "MISCONFIG-NET-001".to_string(),
                    category: MisconfigCategory::Network,
                    title: "MySQL exposed to all interfaces".to_string(),
                    description: "MySQL is listening on 0.0.0.0, allowing connections from any network interface.".to_string(),
                    severity: MisconfigSeverity::High,
                    affected_component: "mysql".to_string(),
                    discovered_at: Utc::now(),
                    remediation_steps: vec![
                        "Edit /etc/mysql/my.cnf".to_string(),
                        "Set: bind-address = 127.0.0.1".to_string(),
                        "Restart MySQL: sudo systemctl restart mysql".to_string(),
                    ],
                    status: MisconfigStatus::New,
                    cis_benchmark_ref: None,
                });
            }

            if listeners.contains("0.0.0.0:5432") {
                findings.push(Misconfiguration {
                    id: "MISCONFIG-NET-002".to_string(),
                    category: MisconfigCategory::Network,
                    title: "PostgreSQL exposed to all interfaces".to_string(),
                    description: "PostgreSQL is listening on 0.0.0.0, allowing connections from any network interface.".to_string(),
                    severity: MisconfigSeverity::High,
                    affected_component: "postgresql".to_string(),
                    discovered_at: Utc::now(),
                    remediation_steps: vec![
                        "Edit /etc/postgresql/*/main/postgresql.conf".to_string(),
                        "Set: listen_addresses = 'localhost'".to_string(),
                    ],
                    status: MisconfigStatus::New,
                    cis_benchmark_ref: None,
                });
            }
        }

        findings
    }

    #[cfg(target_os = "linux")]
    fn check_user_accounts(&self) -> Vec<Misconfiguration> {
        let mut findings = Vec::new();

        // Check for users without passwords
        if let Ok(shadow) = std::fs::read_to_string("/etc/shadow") {
            for line in shadow.lines() {
                let parts: Vec<&str> = line.split(':').collect();
                if parts.len() >= 2 {
                    let username = parts[0];
                    let password_field = parts[1];

                    // Empty or locked password
                    if password_field.is_empty() || password_field == "!" {
                        // Skip system accounts
                        if !username.starts_with("_") && username != "nobody" {
                            findings.push(Misconfiguration {
                                id: format!("MISCONFIG-AUTH-{}", username),
                                category: MisconfigCategory::Authentication,
                                title: format!("User account '{}' has no password", username),
                                description: "User account has no password set or is locked.".to_string(),
                                severity: MisconfigSeverity::Medium,
                                affected_component: username.to_string(),
                                discovered_at: Utc::now(),
                                remediation_steps: vec![
                                    format!("Set password: sudo passwd {}", username),
                                    "Or disable account if not needed: sudo usermod -L".to_string(),
                                ],
                                status: MisconfigStatus::New,
                                cis_benchmark_ref: Some("CIS Ubuntu 22.04 LTS - 5.5".to_string()),
                            });
                        }
                    }
                }
            }
        }

        findings
    }

    #[cfg(target_os = "linux")]
    fn check_file_permissions(&self) -> Vec<Misconfiguration> {
        let mut findings = Vec::new();

        // Check world-writable files in critical directories
        let critical_dirs = ["/etc", "/bin", "/sbin", "/usr/bin", "/usr/sbin"];

        for dir in &critical_dirs {
            if let Ok(output) = Command::new("find")
                .args(&[dir, "-type", "f", "-perm", "-002", "-ls"])
                .output()
            {
                let output_str = String::from_utf8_lossy(&output.stdout);
                if !output_str.is_empty() {
                    findings.push(Misconfiguration {
                        id: format!("MISCONFIG-PERM-{}", dir.replace('/', "-")),
                        category: MisconfigCategory::Permissions,
                        title: format!("World-writable files in {}", dir),
                        description: format!("Found world-writable files in critical system directory {}", dir),
                        severity: MisconfigSeverity::High,
                        affected_component: dir.to_string(),
                        discovered_at: Utc::now(),
                        remediation_steps: vec![
                            format!("Review files: find {} -type f -perm -002 -ls", dir),
                            "Remove world-write: chmod o-w <file>".to_string(),
                        ],
                        status: MisconfigStatus::New,
                        cis_benchmark_ref: Some("CIS Ubuntu 22.04 LTS - 6.1".to_string()),
                    });
                }
            }
        }

        findings
    }

    #[cfg(target_os = "linux")]
    fn check_auditd(&self) -> Vec<Misconfiguration> {
        let mut findings = Vec::new();

        // Check if auditd is running
        if let Ok(output) = Command::new("systemctl")
            .args(&["is-active", "auditd"])
            .output()
        {
            let status = String::from_utf8_lossy(&output.stdout);
            if !status.contains("active") {
                findings.push(Misconfiguration {
                    id: "MISCONFIG-AUDIT-001".to_string(),
                    category: MisconfigCategory::Auditing,
                    title: "System auditing (auditd) not enabled".to_string(),
                    description: "auditd is not running. Security events are not being logged.".to_string(),
                    severity: MisconfigSeverity::Medium,
                    affected_component: "auditd".to_string(),
                    discovered_at: Utc::now(),
                    remediation_steps: vec![
                        "Install: sudo apt-get install auditd".to_string(),
                        "Enable: sudo systemctl enable --now auditd".to_string(),
                    ],
                    status: MisconfigStatus::New,
                    cis_benchmark_ref: Some("CIS Ubuntu 22.04 LTS - 4.1.1".to_string()),
                });
            }
        }

        findings
    }

    // ===== Windows Checks =====

    #[cfg(target_os = "windows")]
    fn check_windows_firewall(&self) -> Vec<Misconfiguration> {
        let mut findings = Vec::new();

        // Check Windows Firewall status via netsh
        if let Ok(output) = Command::new("netsh")
            .args(&["advfirewall", "show", "allprofiles", "state"])
            .output()
        {
            let status = String::from_utf8_lossy(&output.stdout);
            if status.contains("OFF") {
                findings.push(Misconfiguration {
                    id: "MISCONFIG-FW-WIN-001".to_string(),
                    category: MisconfigCategory::Firewall,
                    title: "Windows Firewall disabled".to_string(),
                    description: "Windows Firewall is disabled on one or more profiles.".to_string(),
                    severity: MisconfigSeverity::Critical,
                    affected_component: "Windows Firewall".to_string(),
                    discovered_at: Utc::now(),
                    remediation_steps: vec![
                        "netsh advfirewall set allprofiles state on".to_string(),
                    ],
                    status: MisconfigStatus::New,
                    cis_benchmark_ref: Some("CIS Microsoft Windows 11 - 9.1".to_string()),
                });
            }
        }

        findings
    }

    #[cfg(target_os = "windows")]
    fn check_bitlocker(&self) -> Vec<Misconfiguration> {
        let mut findings = Vec::new();

        // Check BitLocker status
        if let Ok(output) = Command::new("manage-bde")
            .args(&["-status", "C:"])
            .output()
        {
            let status = String::from_utf8_lossy(&output.stdout);
            if !status.contains("Protection On") {
                findings.push(Misconfiguration {
                    id: "MISCONFIG-ENC-WIN-001".to_string(),
                    category: MisconfigCategory::Encryption,
                    title: "BitLocker not enabled".to_string(),
                    description: "BitLocker disk encryption is not enabled on system drive.".to_string(),
                    severity: MisconfigSeverity::Medium,
                    affected_component: "C: drive".to_string(),
                    discovered_at: Utc::now(),
                    remediation_steps: vec![
                        "Enable BitLocker from Control Panel > BitLocker Drive Encryption".to_string(),
                    ],
                    status: MisconfigStatus::New,
                    cis_benchmark_ref: Some("CIS Microsoft Windows 11 - 18.9.6".to_string()),
                });
            }
        }

        findings
    }

    #[cfg(target_os = "windows")]
    fn check_windows_defender(&self) -> Vec<Misconfiguration> {
        // Placeholder for Windows Defender checks
        Vec::new()
    }

    #[cfg(target_os = "windows")]
    fn check_windows_updates(&self) -> Vec<Misconfiguration> {
        // Placeholder for Windows Update checks
        Vec::new()
    }

    #[cfg(target_os = "windows")]
    fn check_user_account_control(&self) -> Vec<Misconfiguration> {
        // Placeholder for UAC checks
        Vec::new()
    }
}

impl Default for MisconfigurationScanner {
    fn default() -> Self {
        Self::new()
    }
}
