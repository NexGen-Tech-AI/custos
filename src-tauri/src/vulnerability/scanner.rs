// Vulnerability Scanner - Scans installed packages against CVE database

use super::database::*;
use crate::sensors::package_sensor::Package;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use parking_lot::Mutex;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityFinding {
    pub id: String,                          // Unique finding ID
    pub cve: CVE,
    pub affected_package: Package,
    pub risk_score: f32,                     // 0.0-100.0 (prioritized score)
    pub exploitable: bool,                   // Has known exploit
    pub exposed: bool,                       // Service exposed to network
    pub fix_available: bool,
    pub recommended_action: RemediationAction,
    pub discovered_at: DateTime<Utc>,
    pub status: FindingStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum FindingStatus {
    New,
    Acknowledged,
    InRemediation,
    Resolved,
    Accepted,                                // Risk accepted, no fix needed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RemediationAction {
    Upgrade { to_version: String, package_manager_command: String },
    Patch { description: String },
    Mitigate { steps: Vec<String> },
    NoFixAvailable,
}

/// Vulnerability Scanner
pub struct VulnerabilityScanner {
    cve_db: CVEDatabase,
    findings: Mutex<HashMap<String, VulnerabilityFinding>>,
    last_scan: Mutex<Option<DateTime<Utc>>>,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        Self {
            cve_db: CVEDatabase::new(),
            findings: Mutex::new(HashMap::new()),
            last_scan: Mutex::new(None),
        }
    }

    /// Scan all installed packages for vulnerabilities
    pub fn scan_packages(&self, packages: &[Package]) -> Vec<VulnerabilityFinding> {
        let mut findings = Vec::new();
        let total_packages = packages.len();
        let mut scanned = 0;
        let mut with_vulns = 0;

        println!("Starting vulnerability scan of {} packages...", total_packages);

        for package in packages {
            scanned += 1;

            // Progress logging every 50 packages or for first/last
            if scanned == 1 || scanned == total_packages || scanned % 50 == 0 {
                println!("Progress: {}/{} packages scanned ({:.1}%)",
                    scanned, total_packages, (scanned as f64 / total_packages as f64) * 100.0);
            }

            // Determine ecosystem from package source
            let ecosystem = match package.source.as_str() {
                "dpkg" => "debian",
                "rpm" => "rhel",
                "pacman" => "arch",
                "apk" => "alpine",
                "windows_update" => "windows",
                _ => "unknown",
            };

            // Query CVE database for this package
            let cves = self.cve_db.query_package(&package.name, &package.version, ecosystem);

            if !cves.is_empty() {
                with_vulns += 1;
                println!("  Found {} CVEs in {} v{}", cves.len(), package.name, package.version);
            }

            for cve in cves {
                let finding = self.create_finding(package.clone(), cve);
                findings.push(finding);
            }
        }

        // Update internal findings cache
        {
            let mut cache = self.findings.lock();
            for finding in &findings {
                cache.insert(finding.id.clone(), finding.clone());
            }
        }

        // Update last scan timestamp
        *self.last_scan.lock() = Some(Utc::now());

        println!("Scan summary: {} vulnerable packages found out of {}", with_vulns, total_packages);

        findings
    }

    /// Create a vulnerability finding from a package and CVE
    fn create_finding(&self, package: Package, cve: CVE) -> VulnerabilityFinding {
        let fix_available = cve.affected_packages.iter().any(|ap| ap.fixed_version.is_some());

        let recommended_action = if fix_available {
            let fixed_version = cve.affected_packages
                .iter()
                .find_map(|ap| ap.fixed_version.clone())
                .unwrap_or_else(|| "latest".to_string());

            let command = Self::generate_upgrade_command(&package.source, &package.name, &fixed_version);

            RemediationAction::Upgrade {
                to_version: fixed_version,
                package_manager_command: command,
            }
        } else {
            RemediationAction::NoFixAvailable
        };

        // Calculate risk score (combination of CVSS, EPSS, KEV status, exploit availability)
        let risk_score = Self::calculate_risk_score(&cve);

        let finding_id = format!("{}-{}", cve.id, package.name);

        VulnerabilityFinding {
            id: finding_id,
            cve: cve.clone(),
            affected_package: package,
            risk_score,
            exploitable: cve.has_exploit || cve.cisa_kev,
            exposed: false,  // TODO: Cross-reference with network sensor data
            fix_available,
            recommended_action,
            discovered_at: Utc::now(),
            status: FindingStatus::New,
        }
    }

    /// Calculate prioritized risk score (0-100)
    /// Formula: Base CVSS * multipliers (KEV, EPSS, exploit availability)
    fn calculate_risk_score(cve: &CVE) -> f32 {
        let base_score = cve.cvss_score.unwrap_or(5.0);

        let mut multiplier = 1.0;

        // KEV catalog = 2x multiplier (known active exploitation)
        if cve.cisa_kev {
            multiplier *= 2.0;
        }

        // High EPSS score = 1.5x multiplier
        if let Some(epss) = cve.epss_score {
            if epss > 0.5 {
                multiplier *= 1.5;
            }
        }

        // Public exploit available = 1.3x multiplier
        if cve.has_exploit {
            multiplier *= 1.3;
        }

        // Normalize to 0-100 scale
        let score = (base_score * multiplier).min(100.0);
        score
    }

    /// Generate package manager command to fix vulnerability
    fn generate_upgrade_command(source: &str, package_name: &str, fixed_version: &str) -> String {
        match source {
            "dpkg" => format!("sudo apt-get install --only-upgrade {}={}", package_name, fixed_version),
            "rpm" => format!("sudo yum update {} -y", package_name),
            "pacman" => format!("sudo pacman -S {}", package_name),
            "apk" => format!("sudo apk upgrade {}", package_name),
            "windows_update" => format!("Install-WindowsUpdate -KBArticleID {}", package_name.trim_start_matches("KB")),
            _ => format!("Update {} to {}", package_name, fixed_version),
        }
    }

    /// Get all findings
    pub fn get_findings(&self) -> Vec<VulnerabilityFinding> {
        let findings = self.findings.lock();
        findings.values().cloned().collect()
    }

    /// Get findings filtered by severity
    pub fn get_findings_by_severity(&self, min_severity: CVESeverity) -> Vec<VulnerabilityFinding> {
        let findings = self.findings.lock();
        findings
            .values()
            .filter(|f| f.cve.severity >= min_severity)
            .cloned()
            .collect()
    }

    /// Get critical/exploitable findings ("fix now" list)
    pub fn get_critical_exploitable(&self) -> Vec<VulnerabilityFinding> {
        let findings = self.findings.lock();
        findings
            .values()
            .filter(|f| {
                (f.cve.severity == CVESeverity::Critical || f.cve.severity == CVESeverity::High)
                    && f.exploitable
            })
            .cloned()
            .collect()
    }

    /// Get findings with available fixes
    pub fn get_fixable(&self) -> Vec<VulnerabilityFinding> {
        let findings = self.findings.lock();
        findings
            .values()
            .filter(|f| f.fix_available)
            .cloned()
            .collect()
    }

    /// Update finding status
    pub fn update_finding_status(&self, finding_id: &str, status: FindingStatus) -> Result<(), String> {
        let mut findings = self.findings.lock();
        if let Some(finding) = findings.get_mut(finding_id) {
            finding.status = status;
            Ok(())
        } else {
            Err("Finding not found".to_string())
        }
    }

    /// Get scan statistics
    pub fn get_scan_stats(&self) -> ScanStatistics {
        let findings = self.findings.lock();

        let total = findings.len();
        let critical = findings.values().filter(|f| f.cve.severity == CVESeverity::Critical).count();
        let high = findings.values().filter(|f| f.cve.severity == CVESeverity::High).count();
        let medium = findings.values().filter(|f| f.cve.severity == CVESeverity::Medium).count();
        let low = findings.values().filter(|f| f.cve.severity == CVESeverity::Low).count();
        let exploitable = findings.values().filter(|f| f.exploitable).count();
        let fix_available = findings.values().filter(|f| f.fix_available).count();

        ScanStatistics {
            total_vulnerabilities: total,
            critical,
            high,
            medium,
            low,
            exploitable,
            fix_available,
            last_scan: *self.last_scan.lock(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanStatistics {
    pub total_vulnerabilities: usize,
    pub critical: usize,
    pub high: usize,
    pub medium: usize,
    pub low: usize,
    pub exploitable: usize,
    pub fix_available: usize,
    pub last_scan: Option<DateTime<Utc>>,
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}
