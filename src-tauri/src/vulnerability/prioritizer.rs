// Vulnerability Prioritizer - Risk-based prioritization beyond CVSS
// Uses CISA KEV, EPSS, exploit availability, and exposure data

use super::scanner::*;
use super::database::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PrioritizedFinding {
    pub finding: VulnerabilityFinding,
    pub priority_score: f32,                  // 0-100 (higher = more urgent)
    pub priority_level: PriorityLevel,
    pub rationale: Vec<String>,               // Why this priority was assigned
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum PriorityLevel {
    Critical,  // Fix immediately (exploited in wild, exposed to internet)
    High,      // Fix within 24-48 hours
    Medium,    // Fix within 1 week
    Low,       // Fix in next patch cycle
    Info,      // Informational only
}

impl PriorityLevel {
    pub fn from_score(score: f32) -> Self {
        match score {
            90.0..=100.0 => PriorityLevel::Critical,
            70.0..=89.9 => PriorityLevel::High,
            40.0..=69.9 => PriorityLevel::Medium,
            10.0..=39.9 => PriorityLevel::Low,
            _ => PriorityLevel::Info,
        }
    }

    pub fn color(&self) -> &'static str {
        match self {
            PriorityLevel::Critical => "red",
            PriorityLevel::High => "orange",
            PriorityLevel::Medium => "yellow",
            PriorityLevel::Low => "blue",
            PriorityLevel::Info => "gray",
        }
    }
}

pub struct VulnerabilityPrioritizer;

impl VulnerabilityPrioritizer {
    /// Prioritize findings using advanced risk scoring
    pub fn prioritize(findings: &[VulnerabilityFinding]) -> Vec<PrioritizedFinding> {
        let mut prioritized: Vec<PrioritizedFinding> = findings
            .iter()
            .map(|f| Self::calculate_priority(f.clone()))
            .collect();

        // Sort by priority score (highest first)
        prioritized.sort_by(|a, b| {
            b.priority_score
                .partial_cmp(&a.priority_score)
                .unwrap_or(std::cmp::Ordering::Equal)
        });

        prioritized
    }

    /// Calculate priority score for a single finding
    fn calculate_priority(finding: VulnerabilityFinding) -> PrioritizedFinding {
        let mut score = 0.0;
        let mut rationale = Vec::new();

        // Base: Start with CVSS score (0-10) * 10 = 0-100
        if let Some(cvss) = finding.cve.cvss_score {
            score += cvss * 10.0;
            rationale.push(format!("Base CVSS: {:.1}", cvss));
        } else {
            score += 50.0; // Default medium severity if no CVSS
            rationale.push("No CVSS score available".to_string());
        }

        // Critical multiplier: CISA KEV catalog (+40 points)
        if finding.cve.cisa_kev {
            score += 40.0;
            rationale.push("⚠ In CISA KEV catalog (actively exploited in wild)".to_string());
        }

        // High multiplier: Public exploit available (+30 points)
        if finding.cve.has_exploit {
            score += 30.0;
            rationale.push("Public exploit/PoC available".to_string());
        }

        // EPSS score multiplier (likelihood of exploitation)
        if let Some(epss) = finding.cve.epss_score {
            let epss_bonus = epss * 20.0; // 0.0-1.0 -> 0-20 points
            score += epss_bonus;
            rationale.push(format!("EPSS score: {:.1}% exploitation probability", epss * 100.0));
        }

        // Exposure multiplier: Service exposed to network (+25 points)
        if finding.exposed {
            score += 25.0;
            rationale.push("Service exposed to network".to_string());
        }

        // Fix availability bonus: Fix available (+10 points for easier remediation)
        if finding.fix_available {
            score += 10.0;
            rationale.push("Fix available".to_string());
        } else {
            rationale.push("⚠ No fix available yet".to_string());
        }

        // Privilege escalation detection (from CVSS vector)
        if let Some(ref vector) = finding.cve.cvss_vector {
            if vector.contains("PR:L") || vector.contains("PR:N") {
                if vector.contains("C:H") || vector.contains("I:H") || vector.contains("A:H") {
                    score += 15.0;
                    rationale.push("Privilege escalation possible".to_string());
                }
            }
        }

        // Remote code execution detection
        if finding.cve.description.to_lowercase().contains("remote code execution")
            || finding.cve.description.to_lowercase().contains("rce") {
            score += 20.0;
            rationale.push("⚠ Remote code execution vulnerability".to_string());
        }

        // Critical system components
        let critical_packages = ["kernel", "sudo", "systemd", "sshd", "openssh", "polkit", "dbus"];
        if critical_packages.iter().any(|&pkg| finding.affected_package.name.contains(pkg)) {
            score += 15.0;
            rationale.push("Affects critical system component".to_string());
        }

        // Cap score at 100
        score = score.min(100.0);

        let priority_level = PriorityLevel::from_score(score);

        PrioritizedFinding {
            finding,
            priority_score: score,
            priority_level,
            rationale,
        }
    }

    /// Get "fix now" list (Critical and High priority only)
    pub fn get_fix_now_list(prioritized: &[PrioritizedFinding]) -> Vec<PrioritizedFinding> {
        prioritized
            .iter()
            .filter(|p| {
                matches!(
                    p.priority_level,
                    PriorityLevel::Critical | PriorityLevel::High
                )
            })
            .cloned()
            .collect()
    }

    /// Group findings by affected package
    pub fn group_by_package(prioritized: &[PrioritizedFinding]) -> Vec<PackageVulnerabilityGroup> {
        use std::collections::HashMap;

        let mut groups: HashMap<String, Vec<PrioritizedFinding>> = HashMap::new();

        for finding in prioritized {
            let package_name = finding.finding.affected_package.name.clone();
            groups
                .entry(package_name)
                .or_insert_with(Vec::new)
                .push(finding.clone());
        }

        let mut result: Vec<PackageVulnerabilityGroup> = groups
            .into_iter()
            .map(|(package_name, findings)| {
                let highest_priority = findings
                    .iter()
                    .map(|f| f.priority_score)
                    .max_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal))
                    .unwrap_or(0.0);

                PackageVulnerabilityGroup {
                    package_name,
                    vulnerability_count: findings.len(),
                    highest_priority,
                    findings,
                }
            })
            .collect();

        // Sort by highest priority
        result.sort_by(|a, b| {
            b.highest_priority
                .partial_cmp(&a.highest_priority)
                .unwrap_or(std::cmp::Ordering::Equal)
        });

        result
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageVulnerabilityGroup {
    pub package_name: String,
    pub vulnerability_count: usize,
    pub highest_priority: f32,
    pub findings: Vec<PrioritizedFinding>,
}
