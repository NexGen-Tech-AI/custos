// CVE Database - Production integration with OSV, NVD, CISA KEV, and EPSS APIs
// Real-time vulnerability lookups with caching for performance

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use parking_lot::Mutex;
use reqwest;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CVE {
    pub id: String,                      // CVE-2024-1234
    pub description: String,
    pub cvss_score: Option<f32>,         // 0.0-10.0
    pub cvss_vector: Option<String>,
    pub severity: CVESeverity,
    pub published_date: String,
    pub modified_date: String,
    pub affected_packages: Vec<AffectedPackage>,
    pub references: Vec<String>,
    pub cisa_kev: bool,                  // In CISA Known Exploited Vulnerabilities catalog
    pub has_exploit: bool,               // Public exploit/PoC available
    pub epss_score: Option<f32>,         // Exploit Prediction Scoring System (0.0-1.0)
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AffectedPackage {
    pub package_name: String,
    pub ecosystem: String,               // debian, alpine, pypi, npm, etc.
    pub affected_versions: Vec<VersionRange>,
    pub fixed_version: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionRange {
    pub introduced: Option<String>,
    pub fixed: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum CVESeverity {
    None,
    Low,
    Medium,
    High,
    Critical,
}

impl CVESeverity {
    pub fn from_cvss_score(score: f32) -> Self {
        match score {
            0.0 => CVESeverity::None,
            0.1..=3.9 => CVESeverity::Low,
            4.0..=6.9 => CVESeverity::Medium,
            7.0..=8.9 => CVESeverity::High,
            9.0..=10.0 => CVESeverity::Critical,
            _ => CVESeverity::None,
        }
    }
}

// OSV API Response Structures
#[derive(Debug, Deserialize)]
struct OSVResponse {
    vulns: Option<Vec<OSVVulnerability>>,
}

#[derive(Debug, Deserialize)]
struct OSVVulnerability {
    id: String,
    summary: Option<String>,
    details: Option<String>,
    #[serde(default)]
    aliases: Vec<String>,
    modified: String,
    published: String,
    #[serde(default)]
    references: Vec<OSVReference>,
    #[serde(default)]
    affected: Vec<OSVAffected>,
    severity: Option<Vec<OSVSeverity>>,
}

#[derive(Debug, Deserialize)]
struct OSVReference {
    #[serde(rename = "type")]
    ref_type: Option<String>,
    url: String,
}

#[derive(Debug, Deserialize)]
struct OSVAffected {
    package: OSVPackage,
    ranges: Option<Vec<OSVRange>>,
    versions: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct OSVPackage {
    name: String,
    ecosystem: String,
}

#[derive(Debug, Deserialize)]
struct OSVRange {
    #[serde(rename = "type")]
    range_type: String,
    events: Vec<OSVEvent>,
}

#[derive(Debug, Deserialize)]
struct OSVEvent {
    introduced: Option<String>,
    fixed: Option<String>,
}

#[derive(Debug, Deserialize)]
struct OSVSeverity {
    #[serde(rename = "type")]
    severity_type: String,
    score: String,
}

// CISA KEV Catalog Structure
#[derive(Debug, Deserialize)]
struct KEVCatalog {
    vulnerabilities: Vec<KEVEntry>,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct KEVEntry {
    #[serde(rename = "cveID")]
    cve_id: String,
}

// EPSS API Response
#[derive(Debug, Deserialize)]
struct EPSSResponse {
    data: Option<Vec<EPSSEntry>>,
}

#[derive(Debug, Deserialize)]
struct EPSSEntry {
    cve: String,
    epss: String,
}

#[derive(Clone)]
struct CachedCVE {
    cve: CVE,
    cached_at: DateTime<Utc>,
}

/// CVE Database Manager - Production implementation with real API integrations
pub struct CVEDatabase {
    cache: Mutex<HashMap<String, CachedCVE>>,
    kev_cache: Mutex<Option<(Vec<String>, DateTime<Utc>)>>,
    client: reqwest::Client,
    enabled: bool,
}

impl CVEDatabase {
    pub fn new() -> Self {
        Self {
            cache: Mutex::new(HashMap::new()),
            kev_cache: Mutex::new(None),
            client: reqwest::Client::builder()
                .timeout(std::time::Duration::from_secs(10))
                .user_agent("Custos/1.0")
                .build()
                .unwrap_or_default(),
            enabled: true,
        }
    }

    /// Look up CVE by ID using OSV API
    pub fn lookup_cve(&self, cve_id: &str) -> Option<CVE> {
        if !self.enabled {
            return None;
        }

        // Check cache first (cache for 1 hour)
        {
            let cache = self.cache.lock();
            if let Some(cached) = cache.get(cve_id) {
                if Utc::now().signed_duration_since(cached.cached_at).num_hours() < 1 {
                    return Some(cached.cve.clone());
                }
            }
        }

        // Query OSV API
        tokio::runtime::Runtime::new().ok()?.block_on(async {
            self.query_osv_by_cve(cve_id).await.ok()
        })
    }

    /// Query vulnerabilities for a specific package using OSV API
    pub fn query_package(&self, package_name: &str, version: &str, ecosystem: &str) -> Vec<CVE> {
        if !self.enabled {
            return Vec::new();
        }

        // Map our ecosystem names to OSV ecosystem names
        let osv_ecosystem = self.map_ecosystem_to_osv(ecosystem);

        // Use tokio runtime to make async call
        let runtime = match tokio::runtime::Runtime::new() {
            Ok(rt) => rt,
            Err(e) => {
                eprintln!("Failed to create tokio runtime: {}", e);
                return Vec::new();
            }
        };

        runtime.block_on(async {
            match self.query_osv_package(package_name, version, &osv_ecosystem).await {
                Ok(cves) => {
                    if !cves.is_empty() {
                        println!("    OSV API: Found {} CVEs for {} v{} ({})",
                            cves.len(), package_name, version, osv_ecosystem);
                    }
                    cves
                },
                Err(e) => {
                    eprintln!("    OSV query failed for {} {}: {}", package_name, version, e);
                    Vec::new()
                }
            }
        })
    }

    /// Batch query for multiple packages
    pub fn batch_query(&self, packages: &[(String, String, String)]) -> HashMap<String, Vec<CVE>> {
        let mut results = HashMap::new();

        for (name, version, ecosystem) in packages {
            let cves = self.query_package(name, version, ecosystem);
            if !cves.is_empty() {
                results.insert(name.clone(), cves);
            }
        }

        results
    }

    /// Check if a vulnerability is in CISA KEV catalog
    pub fn is_known_exploited(&self, cve_id: &str) -> bool {
        // Check cache first (cache for 24 hours)
        {
            let cache = self.kev_cache.lock();
            if let Some((kev_list, cached_at)) = &*cache {
                if Utc::now().signed_duration_since(*cached_at).num_hours() < 24 {
                    return kev_list.contains(&cve_id.to_string());
                }
            }
        }

        // Fetch fresh KEV catalog
        let runtime = match tokio::runtime::Runtime::new() {
            Ok(rt) => rt,
            Err(_) => return false,
        };

        runtime.block_on(async {
            match self.fetch_kev_catalog().await {
                Ok(kev_list) => {
                    let is_kev = kev_list.contains(&cve_id.to_string());

                    // Update cache
                    let mut cache = self.kev_cache.lock();
                    *cache = Some((kev_list, Utc::now()));

                    is_kev
                }
                Err(e) => {
                    eprintln!("Failed to fetch KEV catalog: {}", e);
                    false
                }
            }
        })
    }

    /// Get EPSS (Exploit Prediction Scoring System) score
    pub fn get_epss_score(&self, cve_id: &str) -> Option<f32> {
        let runtime = match tokio::runtime::Runtime::new() {
            Ok(rt) => rt,
            Err(_) => return None,
        };

        runtime.block_on(async {
            self.query_epss(cve_id).await.ok()
        })
    }

    // ===== Private API Methods =====

    /// Query OSV API for a specific package
    async fn query_osv_package(&self, package_name: &str, version: &str, ecosystem: &str) -> Result<Vec<CVE>, String> {
        let url = "https://api.osv.dev/v1/query";

        let body = serde_json::json!({
            "version": version,
            "package": {
                "name": package_name,
                "ecosystem": ecosystem
            }
        });

        let response = self.client
            .post(url)
            .json(&body)
            .send()
            .await
            .map_err(|e| format!("OSV API request failed: {}", e))?;

        if !response.status().is_success() {
            return Ok(Vec::new()); // No vulnerabilities found
        }

        let osv_response: OSVResponse = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse OSV response: {}", e))?;

        let vulns = match osv_response.vulns {
            Some(v) if !v.is_empty() => v,
            _ => return Ok(Vec::new()),
        };

        let mut cves = Vec::new();
        for vuln in vulns {
            if let Some(cve) = self.convert_osv_to_cve(vuln, package_name, ecosystem).await {
                cves.push(cve);
            }
        }

        Ok(cves)
    }

    /// Query OSV API by CVE ID
    async fn query_osv_by_cve(&self, cve_id: &str) -> Result<CVE, String> {
        let url = format!("https://api.osv.dev/v1/vulns/{}", cve_id);

        let response = self.client
            .get(&url)
            .send()
            .await
            .map_err(|e| format!("OSV API request failed: {}", e))?;

        if !response.status().is_success() {
            return Err(format!("CVE not found: {}", cve_id));
        }

        let osv_vuln: OSVVulnerability = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse OSV response: {}", e))?;

        self.convert_osv_to_cve(osv_vuln, "", "")
            .await
            .ok_or_else(|| "Failed to convert OSV data".to_string())
    }

    /// Convert OSV vulnerability to our CVE format
    async fn convert_osv_to_cve(&self, osv: OSVVulnerability, package_name: &str, ecosystem: &str) -> Option<CVE> {
        // Extract CVE ID from aliases or use OSV ID
        let cve_id = osv.aliases.iter()
            .find(|a| a.starts_with("CVE-"))
            .cloned()
            .unwrap_or_else(|| osv.id.clone());

        // Get description
        let description = osv.details.or(osv.summary).unwrap_or_default();

        // Extract CVSS score
        let (cvss_score, cvss_vector) = if let Some(severities) = osv.severity {
            let cvss = severities.iter()
                .find(|s| s.severity_type == "CVSS_V3")
                .or_else(|| severities.first());

            if let Some(cvss) = cvss {
                let score = self.parse_cvss_score(&cvss.score);
                (score, Some(cvss.score.clone()))
            } else {
                (None, None)
            }
        } else {
            (None, None)
        };

        let severity = cvss_score.map(CVESeverity::from_cvss_score).unwrap_or(CVESeverity::Medium);

        // Extract references
        let references: Vec<String> = osv.references.iter()
            .map(|r| r.url.clone())
            .collect();

        // Check for exploits in references
        let has_exploit = references.iter().any(|r| {
            r.contains("exploit") || r.contains("poc") || r.contains("github.com/exploits")
        }) || osv.references.iter().any(|r| {
            r.ref_type.as_ref().map(|t| t.contains("EXPLOIT") || t.contains("EVIDENCE")).unwrap_or(false)
        });

        // Build affected packages list
        let affected_packages: Vec<AffectedPackage> = osv.affected.iter().map(|aff| {
            let version_ranges: Vec<VersionRange> = if let Some(ranges) = &aff.ranges {
                ranges.iter().flat_map(|range| {
                    range.events.iter().filter_map(|event| {
                        if event.introduced.is_some() || event.fixed.is_some() {
                            Some(VersionRange {
                                introduced: event.introduced.clone(),
                                fixed: event.fixed.clone(),
                            })
                        } else {
                            None
                        }
                    })
                }).collect()
            } else {
                Vec::new()
            };

            let fixed_version = version_ranges.iter()
                .find_map(|vr| vr.fixed.clone());

            AffectedPackage {
                package_name: if package_name.is_empty() {
                    aff.package.name.clone()
                } else {
                    package_name.to_string()
                },
                ecosystem: if ecosystem.is_empty() {
                    aff.package.ecosystem.clone()
                } else {
                    ecosystem.to_string()
                },
                affected_versions: version_ranges,
                fixed_version,
            }
        }).collect();

        // Check CISA KEV
        let cisa_kev = self.is_known_exploited(&cve_id);

        // Get EPSS score
        let epss_score = self.get_epss_score(&cve_id);

        let cve = CVE {
            id: cve_id.clone(),
            description,
            cvss_score,
            cvss_vector,
            severity,
            published_date: osv.published,
            modified_date: osv.modified,
            affected_packages,
            references,
            cisa_kev,
            has_exploit,
            epss_score,
        };

        // Cache the result
        {
            let mut cache = self.cache.lock();
            cache.insert(cve_id, CachedCVE {
                cve: cve.clone(),
                cached_at: Utc::now(),
            });
        }

        Some(cve)
    }

    /// Fetch CISA KEV catalog
    async fn fetch_kev_catalog(&self) -> Result<Vec<String>, String> {
        let url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json";

        let response = self.client
            .get(url)
            .send()
            .await
            .map_err(|e| format!("KEV catalog request failed: {}", e))?;

        let kev_catalog: KEVCatalog = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse KEV catalog: {}", e))?;

        Ok(kev_catalog.vulnerabilities.iter().map(|e| e.cve_id.clone()).collect())
    }

    /// Query EPSS API for exploit prediction score
    async fn query_epss(&self, cve_id: &str) -> Result<f32, String> {
        let url = format!("https://api.first.org/data/v1/epss?cve={}", cve_id);

        let response = self.client
            .get(&url)
            .send()
            .await
            .map_err(|e| format!("EPSS API request failed: {}", e))?;

        let epss_response: EPSSResponse = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse EPSS response: {}", e))?;

        if let Some(data) = epss_response.data {
            if let Some(entry) = data.first() {
                return entry.epss.parse::<f32>()
                    .map_err(|e| format!("Failed to parse EPSS score: {}", e));
            }
        }

        Err("No EPSS data available".to_string())
    }

    /// Parse CVSS score from string (handles both score and vector format)
    fn parse_cvss_score(&self, score_str: &str) -> Option<f32> {
        // If it's just a number
        if let Ok(score) = score_str.parse::<f32>() {
            return Some(score);
        }

        // If it's a CVSS vector, extract the base score
        // Format: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
        // We'll calculate a rough score based on the metrics
        if score_str.starts_with("CVSS:") {
            // This is a simplified calculation - in production you'd want proper CVSS parser
            let metrics: HashMap<&str, &str> = score_str
                .split('/')
                .skip(1)
                .filter_map(|m| {
                    let parts: Vec<&str> = m.split(':').collect();
                    if parts.len() == 2 {
                        Some((parts[0], parts[1]))
                    } else {
                        None
                    }
                })
                .collect();

            // Rough calculation based on CIA triad
            let confidentiality: f32 = metrics.get("C").map(|&v| match v {
                "H" => 3.0,
                "L" => 1.0,
                _ => 0.0,
            }).unwrap_or(0.0);

            let integrity: f32 = metrics.get("I").map(|&v| match v {
                "H" => 3.0,
                "L" => 1.0,
                _ => 0.0,
            }).unwrap_or(0.0);

            let availability: f32 = metrics.get("A").map(|&v| match v {
                "H" => 3.0,
                "L" => 1.0,
                _ => 0.0,
            }).unwrap_or(0.0);

            let base: f32 = confidentiality + integrity + availability;
            return Some(base.min(10.0));
        }

        None
    }

    /// Map our ecosystem names to OSV ecosystem names
    fn map_ecosystem_to_osv(&self, ecosystem: &str) -> String {
        match ecosystem.to_lowercase().as_str() {
            "debian" | "dpkg" => "Debian".to_string(),
            "ubuntu" => "Debian".to_string(),  // OSV uses Debian for Ubuntu packages
            "rhel" | "rpm" | "fedora" | "centos" => "Rocky Linux".to_string(),
            "arch" | "pacman" => "Arch".to_string(),
            "alpine" | "apk" => "Alpine".to_string(),
            "windows" | "windows_update" => "Windows".to_string(),
            "pypi" | "pip" => "PyPI".to_string(),
            "npm" => "npm".to_string(),
            "cargo" | "crates" => "crates.io".to_string(),
            "go" => "Go".to_string(),
            "maven" => "Maven".to_string(),
            _ => ecosystem.to_string(),
        }
    }
}

impl Default for CVEDatabase {
    fn default() -> Self {
        Self::new()
    }
}
