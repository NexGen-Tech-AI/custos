// Comprehensive System Scanner - Scans files, packages, firmware, processes, memory
// Provides Norton-style complete system protection

use std::path::{Path, PathBuf};
use std::fs;
use serde::{Serialize, Deserialize};
use std::sync::Arc;
use parking_lot::Mutex;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComprehensiveScanProgress {
    pub scan_phase: ScanPhase,
    pub total_items: usize,
    pub items_scanned: usize,
    pub threats_found: usize,
    pub critical_threats: usize,
    pub current_item: String,
    pub elapsed_seconds: u64,
    pub eta_seconds: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ScanPhase {
    Initializing,
    ScanningPackages,
    ScanningFiles,
    ScanningFirmware,
    ScanningProcesses,
    ScanningMemory,
    Complete,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatFinding {
    pub id: String,
    pub threat_type: ThreatType,
    pub severity: ThreatSeverity,
    pub location: String,
    pub description: String,
    pub recommended_action: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ThreatType {
    Malware,
    Vulnerability,
    SuspiciousFile,
    FirmwareTampering,
    SuspiciousProcess,
    MemoryAnomaly,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
#[serde(rename_all = "snake_case")]
pub enum ThreatSeverity {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Clone)]
pub struct ComprehensiveScanner {
    progress: Arc<Mutex<ComprehensiveScanProgress>>,
    scan_paths: Vec<PathBuf>,
    malware_signatures: Vec<MalwareSignature>,
}

#[derive(Clone)]
struct MalwareSignature {
    name: String,
    pattern: Vec<u8>,
    description: String,
}

impl ComprehensiveScanner {
    pub fn new() -> Self {
        // Initialize with common malware signatures
        let malware_signatures = vec![
            MalwareSignature {
                name: "ELF_TROJAN".to_string(),
                pattern: vec![0x7F, 0x45, 0x4C, 0x46], // ELF header - check for suspicious behavior
                description: "Suspicious ELF executable".to_string(),
            },
            MalwareSignature {
                name: "SCRIPT_INJECTION".to_string(),
                pattern: b"eval(base64_decode".to_vec(),
                description: "Potential PHP injection".to_string(),
            },
        ];

        // Critical directories to scan
        let scan_paths = vec![
            PathBuf::from("/bin"),
            PathBuf::from("/sbin"),
            PathBuf::from("/usr/bin"),
            PathBuf::from("/usr/sbin"),
            PathBuf::from("/usr/local/bin"),
            PathBuf::from("/etc"),
            PathBuf::from("/boot"),
            PathBuf::from("/lib"),
            PathBuf::from("/usr/lib"),
            PathBuf::from("/home"),
            PathBuf::from("/tmp"),
            PathBuf::from("/var/tmp"),
        ];

        Self {
            progress: Arc::new(Mutex::new(ComprehensiveScanProgress {
                scan_phase: ScanPhase::Initializing,
                total_items: 0,
                items_scanned: 0,
                threats_found: 0,
                critical_threats: 0,
                current_item: String::new(),
                elapsed_seconds: 0,
                eta_seconds: None,
            })),
            scan_paths,
            malware_signatures,
        }
    }

    pub fn get_progress(&self) -> ComprehensiveScanProgress {
        self.progress.lock().clone()
    }

    /// Scan entire system comprehensively
    pub async fn scan_system(&self) -> Vec<ThreatFinding> {
        let mut all_findings = Vec::new();
        let start_time = std::time::Instant::now();

        // Phase 1: Scan Packages
        {
            let mut progress = self.progress.lock();
            progress.scan_phase = ScanPhase::ScanningPackages;
            progress.current_item = "Scanning installed packages...".to_string();
        }

        let package_findings = self.scan_packages().await;
        all_findings.extend(package_findings);

        // Phase 2: Scan Files
        {
            let mut progress = self.progress.lock();
            progress.scan_phase = ScanPhase::ScanningFiles;
            progress.current_item = "Scanning file system...".to_string();
        }

        let file_findings = self.scan_files().await;
        all_findings.extend(file_findings);

        // Phase 3: Scan Firmware
        {
            let mut progress = self.progress.lock();
            progress.scan_phase = ScanPhase::ScanningFirmware;
            progress.current_item = "Scanning firmware and boot records...".to_string();
        }

        let firmware_findings = self.scan_firmware().await;
        all_findings.extend(firmware_findings);

        // Phase 4: Scan Running Processes
        {
            let mut progress = self.progress.lock();
            progress.scan_phase = ScanPhase::ScanningProcesses;
            progress.current_item = "Scanning running processes...".to_string();
        }

        let process_findings = self.scan_processes().await;
        all_findings.extend(process_findings);

        // Phase 5: Scan Memory
        {
            let mut progress = self.progress.lock();
            progress.scan_phase = ScanPhase::ScanningMemory;
            progress.current_item = "Scanning memory for anomalies...".to_string();
        }

        let memory_findings = self.scan_memory().await;
        all_findings.extend(memory_findings);

        // Complete
        {
            let mut progress = self.progress.lock();
            progress.scan_phase = ScanPhase::Complete;
            progress.elapsed_seconds = start_time.elapsed().as_secs();
            progress.threats_found = all_findings.len();
            progress.critical_threats = all_findings.iter()
                .filter(|f| f.severity == ThreatSeverity::Critical)
                .count();
        }

        all_findings
    }

    async fn scan_packages(&self) -> Vec<ThreatFinding> {
        // This will use the existing PackageSensor and VulnerabilityScanner
        // For now, return empty - will integrate with existing code
        Vec::new()
    }

    async fn scan_files(&self) -> Vec<ThreatFinding> {
        let mut findings = Vec::new();
        let mut total_files = 0;

        // Count total files first
        for path in &self.scan_paths {
            if let Ok(count) = self.count_files(path) {
                total_files += count;
            }
        }

        {
            let mut progress = self.progress.lock();
            progress.total_items = total_files;
            progress.items_scanned = 0;
        }

        // Scan each directory
        for path in &self.scan_paths {
            let path_findings = self.scan_directory_recursive(path).await;
            findings.extend(path_findings);
        }

        findings
    }

    fn scan_directory_recursive_sync(&self, path: &Path, depth: usize) -> Vec<ThreatFinding> {
        let mut findings = Vec::new();

        // Limit recursion depth to prevent infinite loops
        if depth > 10 || !path.exists() {
            return findings;
        }

        // Read directory entries
        let entries = match fs::read_dir(path) {
            Ok(e) => e,
            Err(_) => return findings,
        };

        for entry in entries.flatten() {
            let entry_path = entry.path();

            // Update progress
            {
                let mut progress = self.progress.lock();
                progress.items_scanned += 1;
                progress.current_item = entry_path.display().to_string();
            }

            // Scan file for malware signatures
            if entry_path.is_file() {
                if let Some(finding) = self.scan_file_for_malware(&entry_path) {
                    findings.push(finding);
                }
            } else if entry_path.is_dir() {
                // Recursively scan subdirectories
                let sub_findings = self.scan_directory_recursive_sync(&entry_path, depth + 1);
                findings.extend(sub_findings);
            }
        }

        findings
    }

    async fn scan_directory_recursive(&self, path: &Path) -> Vec<ThreatFinding> {
        // Use tokio blocking task for sync file operations
        let path = path.to_path_buf();
        let progress = Arc::clone(&self.progress);
        let signatures = self.malware_signatures.clone();

        tokio::task::spawn_blocking(move || {
            let scanner = Self {
                progress,
                scan_paths: Vec::new(),
                malware_signatures: signatures,
            };
            scanner.scan_directory_recursive_sync(&path, 0)
        })
        .await
        .unwrap_or_else(|_| Vec::new())
    }

    fn scan_file_for_malware(&self, path: &Path) -> Option<ThreatFinding> {
        // Read file content (limit to first 8KB for signature scanning)
        let content = match fs::read(path) {
            Ok(c) => if c.len() > 8192 { c[..8192].to_vec() } else { c },
            Err(_) => return None,
        };

        // Check against malware signatures
        for signature in &self.malware_signatures {
            if self.contains_pattern(&content, &signature.pattern) {
                return Some(ThreatFinding {
                    id: format!("FILE_{}", path.display()),
                    threat_type: ThreatType::SuspiciousFile,
                    severity: ThreatSeverity::High,
                    location: path.display().to_string(),
                    description: format!("Matched signature: {}", signature.description),
                    recommended_action: "Quarantine and review file".to_string(),
                });
            }
        }

        // Check for suspicious permissions
        if path.starts_with("/tmp") || path.starts_with("/var/tmp") {
            if let Ok(metadata) = fs::metadata(path) {
                #[cfg(unix)]
                {
                    use std::os::unix::fs::PermissionsExt;
                    let perms = metadata.permissions().mode();
                    // Check for SUID/SGID in tmp
                    if (perms & 0o4000) != 0 || (perms & 0o2000) != 0 {
                        return Some(ThreatFinding {
                            id: format!("SUID_{}", path.display()),
                            threat_type: ThreatType::SuspiciousFile,
                            severity: ThreatSeverity::High,
                            location: path.display().to_string(),
                            description: "SUID/SGID binary in temporary directory".to_string(),
                            recommended_action: "Investigate and remove if malicious".to_string(),
                        });
                    }
                }
            }
        }

        None
    }

    fn contains_pattern(&self, haystack: &[u8], needle: &[u8]) -> bool {
        haystack.windows(needle.len()).any(|window| window == needle)
    }

    fn count_files(&self, path: &Path) -> Result<usize, std::io::Error> {
        let mut count = 0;
        if !path.exists() {
            return Ok(0);
        }

        for entry in fs::read_dir(path)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_file() {
                count += 1;
            } else if path.is_dir() {
                count += self.count_files(&path).unwrap_or(0);
            }
        }
        Ok(count)
    }

    async fn scan_firmware(&self) -> Vec<ThreatFinding> {
        let mut findings = Vec::new();

        // Check boot records
        if Path::new("/boot/grub/grub.cfg").exists() {
            // Scan GRUB configuration for tampering
            if let Ok(content) = fs::read_to_string("/boot/grub/grub.cfg") {
                if content.contains("rootkit") || content.contains("backdoor") {
                    findings.push(ThreatFinding {
                        id: "FIRMWARE_GRUB_TAMPER".to_string(),
                        threat_type: ThreatType::FirmwareTampering,
                        severity: ThreatSeverity::Critical,
                        location: "/boot/grub/grub.cfg".to_string(),
                        description: "Suspicious content in GRUB configuration".to_string(),
                        recommended_action: "Restore from backup and investigate".to_string(),
                    });
                }
            }
        }

        // Check EFI variables (if accessible)
        if Path::new("/sys/firmware/efi").exists() {
            // Check for Secure Boot status
            if let Ok(content) = fs::read_to_string("/sys/firmware/efi/efivars/SecureBoot-*") {
                if content.contains("0") {
                    findings.push(ThreatFinding {
                        id: "FIRMWARE_SECUREBOOT_OFF".to_string(),
                        threat_type: ThreatType::FirmwareTampering,
                        severity: ThreatSeverity::Medium,
                        location: "UEFI Secure Boot".to_string(),
                        description: "Secure Boot is disabled".to_string(),
                        recommended_action: "Enable Secure Boot in BIOS/UEFI".to_string(),
                    });
                }
            }
        }

        findings
    }

    async fn scan_processes(&self) -> Vec<ThreatFinding> {
        let mut findings = Vec::new();

        // Scan /proc for suspicious processes
        if let Ok(entries) = fs::read_dir("/proc") {
            for entry in entries.flatten() {
                if let Ok(pid) = entry.file_name().to_string_lossy().parse::<u32>() {
                    // Check process command line
                    let cmdline_path = format!("/proc/{}/cmdline", pid);
                    if let Ok(cmdline) = fs::read_to_string(&cmdline_path) {
                        // Check for cryptocurrency miners
                        if cmdline.contains("xmrig") || cmdline.contains("cpuminer") {
                            findings.push(ThreatFinding {
                                id: format!("PROC_MINER_{}", pid),
                                threat_type: ThreatType::SuspiciousProcess,
                                severity: ThreatSeverity::High,
                                location: format!("Process {}", pid),
                                description: "Cryptocurrency miner detected".to_string(),
                                recommended_action: "Terminate process and remove".to_string(),
                            });
                        }
                    }
                }
            }
        }

        findings
    }

    async fn scan_memory(&self) -> Vec<ThreatFinding> {
        // Memory scanning would require root and special tools
        // Placeholder for now
        Vec::new()
    }
}

impl Default for ComprehensiveScanner {
    fn default() -> Self {
        Self::new()
    }
}
