/*!
 * Credential Theft Detection Engine
 *
 * Advanced detection of credential theft attacks:
 * - Keylogger detection (hooks, DLL injection)
 * - Password dumper detection (Mimikatz, LSASS access)
 * - Clipboard monitoring and theft detection
 * - Form grabber detection
 * - Screen capture detection
 * - Browser credential theft
 * - Memory credential scraping
 * - Pass-the-Hash / Pass-the-Ticket attacks
 */

use std::collections::{HashMap, HashSet, VecDeque};
use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};

/// Credential theft detection engine
pub struct CredentialTheftDetector {
    detected_threats: Vec<CredentialThreat>,
    monitored_processes: HashMap<u32, ProcessCredentialActivity>,
    keylogger_patterns: Vec<KeyloggerPattern>,
    suspicious_processes: HashSet<String>,
    lsass_access_log: VecDeque<LsassAccess>,
    config: CredentialDetectorConfig,
}

/// Configuration for credential theft detection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CredentialDetectorConfig {
    pub enabled: bool,
    pub monitor_keyloggers: bool,
    pub monitor_lsass_access: bool,
    pub monitor_clipboard: bool,
    pub monitor_browser_creds: bool,
    pub monitor_screen_capture: bool,
    pub detect_mimikatz: bool,
    pub block_lsass_dumps: bool,
}

impl Default for CredentialDetectorConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            monitor_keyloggers: true,
            monitor_lsass_access: true,
            monitor_clipboard: true,
            monitor_browser_creds: true,
            monitor_screen_capture: true,
            detect_mimikatz: true,
            block_lsass_dumps: true,
        }
    }
}

/// Detected credential theft threat
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CredentialThreat {
    pub id: String,
    pub detected_at: i64,
    pub threat_type: CredentialThreatType,
    pub severity: ThreatSeverity,
    pub process_id: u32,
    pub process_name: String,
    pub indicators: Vec<ThreatIndicator>,
    pub confidence: f64,
    pub action_taken: Option<String>,
}

/// Type of credential threat
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CredentialThreatType {
    Keylogger,
    PasswordDumper,
    ClipboardTheft,
    FormGrabber,
    ScreenCapture,
    BrowserCredentialTheft,
    MemoryScraping,
    PassTheHash,
    PassTheTicket,
    LsassDump,
}

/// Threat severity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]
pub enum ThreatSeverity {
    Critical,
    High,
    Medium,
    Low,
}

/// Threat indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatIndicator {
    pub indicator_type: String,
    pub description: String,
    pub weight: f64,
}

/// Process credential-related activity
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessCredentialActivity {
    pub process_id: u32,
    pub process_name: String,
    pub started_at: i64,
    pub keyboard_hooks: usize,
    pub lsass_access_attempts: usize,
    pub clipboard_access: usize,
    pub screen_captures: usize,
    pub browser_memory_reads: usize,
    pub suspicious_api_calls: Vec<SuspiciousApiCall>,
    pub threat_score: f64,
}

/// Suspicious API call
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuspiciousApiCall {
    pub timestamp: i64,
    pub api_name: String,
    pub parameters: Vec<String>,
    pub reason: String,
}

/// Keylogger detection pattern
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyloggerPattern {
    pub pattern_type: KeyloggerPatternType,
    pub signature: String,
    pub weight: f64,
}

/// Type of keylogger pattern
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum KeyloggerPatternType {
    KernelHook,           // SetWindowsHookEx
    RawInput,             // Raw input API usage
    KeyboardState,        // GetAsyncKeyState, GetKeyState
    RegistryPersistence,  // Run key modifications
    HiddenWindow,         // Hidden windows for message handling
    DllInjection,         // Injected into target processes
}

/// LSASS access record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LsassAccess {
    pub timestamp: i64,
    pub process_id: u32,
    pub process_name: String,
    pub access_type: LsassAccessType,
    pub blocked: bool,
}

/// Type of LSASS access
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum LsassAccessType {
    ProcessOpen,
    MemoryRead,
    MemoryDump,
    DebugPrivilege,
}

impl CredentialTheftDetector {
    /// Create new credential theft detector
    pub fn new(config: CredentialDetectorConfig) -> Result<Self, String> {
        log::info!("üîê Initializing credential theft detector");

        let mut detector = Self {
            detected_threats: Vec::new(),
            monitored_processes: HashMap::new(),
            keylogger_patterns: Vec::new(),
            suspicious_processes: HashSet::new(),
            lsass_access_log: VecDeque::new(),
            config,
        };

        // Load keylogger detection patterns
        detector.load_keylogger_patterns();

        // Load known password dumper process names
        detector.load_suspicious_processes();

        log::info!("‚úÖ Credential theft detector initialized");
        Ok(detector)
    }

    /// Load keylogger detection patterns
    fn load_keylogger_patterns(&mut self) {
        self.keylogger_patterns = vec![
            KeyloggerPattern {
                pattern_type: KeyloggerPatternType::KernelHook,
                signature: "SetWindowsHookEx".to_string(),
                weight: 0.6,
            },
            KeyloggerPattern {
                pattern_type: KeyloggerPatternType::KeyboardState,
                signature: "GetAsyncKeyState".to_string(),
                weight: 0.5,
            },
            KeyloggerPattern {
                pattern_type: KeyloggerPatternType::KeyboardState,
                signature: "GetKeyState".to_string(),
                weight: 0.5,
            },
            KeyloggerPattern {
                pattern_type: KeyloggerPatternType::RawInput,
                signature: "RegisterRawInputDevices".to_string(),
                weight: 0.4,
            },
        ];

        log::debug!("Loaded {} keylogger patterns", self.keylogger_patterns.len());
    }

    /// Load known suspicious process names
    fn load_suspicious_processes(&mut self) {
        // Known password dumper tools
        let dumpers = vec![
            "mimikatz", "procdump", "pwdump", "gsecdump", "wce",
            "quarks-pwdump", "cachedump", "lslsass", "lazagne", "credump",
        ];

        for dumper in dumpers {
            self.suspicious_processes.insert(dumper.to_string());
        }

        log::debug!("Loaded {} suspicious processes", self.suspicious_processes.len());
    }

    /// Detect keylogger activity
    pub fn detect_keylogger(&mut self, process_id: u32, process_name: &str) -> Result<Option<CredentialThreat>, String> {
        // Get or create process activity record
        let activity = self.monitored_processes
            .entry(process_id)
            .or_insert_with(|| ProcessCredentialActivity {
                process_id,
                process_name: process_name.to_string(),
                started_at: Self::current_timestamp(),
                keyboard_hooks: 0,
                lsass_access_attempts: 0,
                clipboard_access: 0,
                screen_captures: 0,
                browser_memory_reads: 0,
                suspicious_api_calls: Vec::new(),
                threat_score: 0.0,
            });

        // Simulate keylogger detection (in production, this would use API monitoring)
        let mut threat_score = 0.0;
        let mut indicators = Vec::new();

        // Check for keyboard hooks
        if activity.keyboard_hooks > 0 {
            threat_score += 0.6;
            indicators.push(ThreatIndicator {
                indicator_type: "KeyboardHook".to_string(),
                description: "Keyboard hook detected".to_string(),
                weight: 0.6,
            });
        }

        // Check for hidden windows
        // (In production, enumerate windows and check for WS_EX_TOOLWINDOW)

        // Check for suspicious API calls
        for api_call in &activity.suspicious_api_calls {
            if api_call.api_name.contains("GetAsyncKeyState") ||
               api_call.api_name.contains("GetKeyState") {
                threat_score += 0.5;
                indicators.push(ThreatIndicator {
                    indicator_type: "KeyboardStateAPI".to_string(),
                    description: format!("Suspicious API: {}", api_call.api_name),
                    weight: 0.5,
                });
            }
        }

        activity.threat_score = threat_score;

        // Determine if this is a keylogger
        if threat_score >= 0.7 {
            log::error!(
                "üö® Keylogger detected: {} (PID {}) - Confidence: {:.1}%",
                process_name, process_id, threat_score * 100.0
            );

            let threat = CredentialThreat {
                id: format!("KEYLOG-{}-{}", process_id, Self::current_timestamp()),
                detected_at: Self::current_timestamp(),
                threat_type: CredentialThreatType::Keylogger,
                severity: ThreatSeverity::Critical,
                process_id,
                process_name: process_name.to_string(),
                indicators,
                confidence: threat_score,
                action_taken: None,
            };

            self.detected_threats.push(threat.clone());
            return Ok(Some(threat));
        }

        Ok(None)
    }

    /// Detect LSASS access (password dumping attempt)
    pub fn detect_lsass_access(
        &mut self,
        process_id: u32,
        process_name: &str,
        access_type: LsassAccessType,
    ) -> Result<Option<CredentialThreat>, String> {
        log::warn!(
            "‚ö†Ô∏è  LSASS access attempt: {} (PID {}) - Type: {:?}",
            process_name, process_id, access_type
        );

        // Record access
        let access = LsassAccess {
            timestamp: Self::current_timestamp(),
            process_id,
            process_name: process_name.to_string(),
            access_type: access_type.clone(),
            blocked: self.config.block_lsass_dumps,
        };

        self.lsass_access_log.push_back(access);

        // Keep only last 1000 entries
        if self.lsass_access_log.len() > 1000 {
            self.lsass_access_log.pop_front();
        }

        // Check if process name is suspicious (before mutable borrow)
        let is_suspicious = self.is_suspicious_process(process_name);

        // Update process activity
        let activity = self.monitored_processes
            .entry(process_id)
            .or_insert_with(|| ProcessCredentialActivity {
                process_id,
                process_name: process_name.to_string(),
                started_at: Self::current_timestamp(),
                keyboard_hooks: 0,
                lsass_access_attempts: 0,
                clipboard_access: 0,
                screen_captures: 0,
                browser_memory_reads: 0,
                suspicious_api_calls: Vec::new(),
                threat_score: 0.0,
            });

        activity.lsass_access_attempts += 1;

        // Calculate threat score
        let mut threat_score: f64 = 0.0;
        let mut indicators = Vec::new();

        // Check if process name is suspicious
        if is_suspicious {
            threat_score += 0.9;
            indicators.push(ThreatIndicator {
                indicator_type: "SuspiciousProcess".to_string(),
                description: format!("Known password dumper: {}", process_name),
                weight: 0.9,
            });
        }

        // Check access type
        match access_type {
            LsassAccessType::MemoryDump => {
                threat_score += 0.8;
                indicators.push(ThreatIndicator {
                    indicator_type: "MemoryDump".to_string(),
                    description: "Attempting to dump LSASS memory".to_string(),
                    weight: 0.8,
                });
            }
            LsassAccessType::MemoryRead => {
                threat_score += 0.6;
                indicators.push(ThreatIndicator {
                    indicator_type: "MemoryRead".to_string(),
                    description: "Reading LSASS memory".to_string(),
                    weight: 0.6,
                });
            }
            LsassAccessType::DebugPrivilege => {
                threat_score += 0.5;
                indicators.push(ThreatIndicator {
                    indicator_type: "DebugPrivilege".to_string(),
                    description: "SeDebugPrivilege enabled".to_string(),
                    weight: 0.5,
                });
            }
            _ => {}
        }

        // Multiple access attempts
        if activity.lsass_access_attempts > 3 {
            threat_score += 0.3;
            indicators.push(ThreatIndicator {
                indicator_type: "RepeatedAccess".to_string(),
                description: format!("{} LSASS access attempts", activity.lsass_access_attempts),
                weight: 0.3,
            });
        }

        activity.threat_score = threat_score.min(1.0);

        // Determine if this is a password dumping attack
        if threat_score >= 0.7 {
            log::error!(
                "üö® Password dumping detected: {} (PID {}) - Confidence: {:.1}%",
                process_name, process_id, threat_score * 100.0
            );

            let threat = CredentialThreat {
                id: format!("PWDUMP-{}-{}", process_id, Self::current_timestamp()),
                detected_at: Self::current_timestamp(),
                threat_type: CredentialThreatType::PasswordDumper,
                severity: ThreatSeverity::Critical,
                process_id,
                process_name: process_name.to_string(),
                indicators,
                confidence: threat_score,
                action_taken: if self.config.block_lsass_dumps {
                    Some("Access blocked".to_string())
                } else {
                    None
                },
            };

            self.detected_threats.push(threat.clone());
            return Ok(Some(threat));
        }

        Ok(None)
    }

    /// Check if process name is suspicious
    fn is_suspicious_process(&self, process_name: &str) -> bool {
        let name_lower = process_name.to_lowercase();

        // Check against known dumpers
        for suspicious in &self.suspicious_processes {
            if name_lower.contains(suspicious) {
                return true;
            }
        }

        // Check for common dumper patterns
        let suspicious_patterns = vec![
            "dump", "pwd", "cred", "mimik", "lazag", "procd",
        ];

        for pattern in suspicious_patterns {
            if name_lower.contains(pattern) {
                return true;
            }
        }

        false
    }

    /// Detect clipboard credential theft
    pub fn detect_clipboard_theft(&mut self, process_id: u32, process_name: &str) -> Result<Option<CredentialThreat>, String> {
        let activity = self.monitored_processes
            .entry(process_id)
            .or_insert_with(|| ProcessCredentialActivity {
                process_id,
                process_name: process_name.to_string(),
                started_at: Self::current_timestamp(),
                keyboard_hooks: 0,
                lsass_access_attempts: 0,
                clipboard_access: 0,
                screen_captures: 0,
                browser_memory_reads: 0,
                suspicious_api_calls: Vec::new(),
                threat_score: 0.0,
            });

        activity.clipboard_access += 1;

        // If excessive clipboard access (>50 times), flag as credential theft
        if activity.clipboard_access > 50 {
            log::warn!(
                "‚ö†Ô∏è  Excessive clipboard access: {} (PID {}) - {} accesses",
                process_name, process_id, activity.clipboard_access
            );

            let threat = CredentialThreat {
                id: format!("CLIP-{}-{}", process_id, Self::current_timestamp()),
                detected_at: Self::current_timestamp(),
                threat_type: CredentialThreatType::ClipboardTheft,
                severity: ThreatSeverity::Medium,
                process_id,
                process_name: process_name.to_string(),
                indicators: vec![
                    ThreatIndicator {
                        indicator_type: "ClipboardAccess".to_string(),
                        description: format!("{} clipboard accesses", activity.clipboard_access),
                        weight: 0.6,
                    }
                ],
                confidence: 0.6,
                action_taken: None,
            };

            self.detected_threats.push(threat.clone());
            return Ok(Some(threat));
        }

        Ok(None)
    }

    /// Record suspicious API call
    pub fn record_api_call(&mut self, process_id: u32, api_name: String, parameters: Vec<String>) {
        if let Some(activity) = self.monitored_processes.get_mut(&process_id) {
            activity.suspicious_api_calls.push(SuspiciousApiCall {
                timestamp: Self::current_timestamp(),
                api_name,
                parameters,
                reason: "Credential-related API".to_string(),
            });
        }
    }

    /// Get current timestamp
    fn current_timestamp() -> i64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64
    }

    /// Get detection statistics
    pub fn get_stats(&self) -> CredentialDetectionStats {
        CredentialDetectionStats {
            total_threats: self.detected_threats.len(),
            keyloggers: self.detected_threats.iter()
                .filter(|t| t.threat_type == CredentialThreatType::Keylogger)
                .count(),
            password_dumpers: self.detected_threats.iter()
                .filter(|t| t.threat_type == CredentialThreatType::PasswordDumper)
                .count(),
            lsass_access_attempts: self.lsass_access_log.len(),
            monitored_processes: self.monitored_processes.len(),
        }
    }

    /// Get all detected threats
    pub fn get_threats(&self) -> Vec<CredentialThreat> {
        self.detected_threats.clone()
    }
}

/// Credential detection statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CredentialDetectionStats {
    pub total_threats: usize,
    pub keyloggers: usize,
    pub password_dumpers: usize,
    pub lsass_access_attempts: usize,
    pub monitored_processes: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_credential_detector() {
        let config = CredentialDetectorConfig::default();
        let detector = CredentialTheftDetector::new(config);
        assert!(detector.is_ok());
    }

    #[test]
    fn test_suspicious_process_detection() {
        let config = CredentialDetectorConfig::default();
        let detector = CredentialTheftDetector::new(config).unwrap();

        assert!(detector.is_suspicious_process("mimikatz.exe"));
        assert!(detector.is_suspicious_process("procdump.exe"));
        assert!(!detector.is_suspicious_process("chrome.exe"));
    }
}
