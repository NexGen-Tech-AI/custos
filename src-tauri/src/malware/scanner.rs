/*!
 * Malware Scanning Engine
 *
 * Multi-layered malware detection:
 * 1. Hash-based detection (instant, 100% accurate for known malware)
 * 2. YARA signature scanning (fast, pattern-based)
 * 3. ML-based detection (slower, detects unknown malware)
 *
 * Performance targets:
 * - Hash check: <1ms
 * - YARA scan: <50ms
 * - ML inference: <10ms
 * - Total: <100ms per file
 */

use std::path::Path;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use serde::{Serialize, Deserialize};
use sha2::{Sha256, Digest};
use regex::bytes::Regex;

use crate::malware::signature_db::SignatureDB;

/// Scan result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    /// Is file malicious
    pub is_malicious: bool,

    /// Threat name (e.g., "Trojan.Generic", "Ransomware.WannaCry")
    pub threat_name: Option<String>,

    /// Detection method
    pub detection_method: DetectionMethod,

    /// Confidence score (0.0 - 1.0)
    pub confidence: f32,

    /// File hash (SHA256)
    pub file_hash: String,

    /// File size
    pub file_size: u64,

    /// Scan duration (milliseconds)
    pub scan_duration_ms: u64,

    /// Additional details
    pub details: ScanDetails,
}

/// Detection method used
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DetectionMethod {
    /// Hash-based detection (known malware)
    Hash,

    /// YARA signature match
    Yara {
        rule_name: String,
        rule_category: String,
    },

    /// Machine learning prediction
    MachineLearning {
        model_name: String,
        probability: f32,
    },

    /// Behavioral analysis
    Behavioral {
        suspicious_behaviors: Vec<String>,
    },

    /// Multiple detection methods agreed
    Ensemble {
        methods: Vec<String>,
    },
}

/// Detailed scan information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanDetails {
    /// Hash check result
    pub hash_malicious: bool,

    /// YARA matches
    pub yara_matches: Vec<String>,

    /// ML prediction
    pub ml_prediction: Option<f32>,

    /// Suspicious indicators
    pub suspicious_indicators: Vec<String>,

    /// File type
    pub file_type: Option<String>,

    /// Packer detected
    pub packer_detected: Option<String>,
}

/// Compiled signature pattern
#[derive(Debug, Clone)]
pub struct SignaturePattern {
    pub name: String,
    pub category: String,
    pub patterns: Vec<String>, // String patterns to match
    pub hex_patterns: Vec<Vec<u8>>, // Binary patterns to match
}

/// File scanner
pub struct FileScanner {
    signature_db: Arc<SignatureDB>,
    signature_patterns: Vec<SignaturePattern>,
    scan_config: ScanConfig,
}

/// Scan configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanConfig {
    /// Enable hash-based detection
    pub enable_hash_check: bool,

    /// Enable YARA scanning
    pub enable_yara: bool,

    /// Enable ML detection
    pub enable_ml: bool,

    /// Enable behavioral analysis
    pub enable_behavioral: bool,

    /// Maximum file size to scan (bytes)
    pub max_file_size: u64,

    /// Timeout per file (seconds)
    pub scan_timeout: u64,
}

impl Default for ScanConfig {
    fn default() -> Self {
        Self {
            enable_hash_check: true,
            enable_yara: true,
            enable_ml: true,
            enable_behavioral: true,
            max_file_size: 500 * 1024 * 1024, // 500MB
            scan_timeout: 30, // 30 seconds
        }
    }
}

impl FileScanner {
    /// Create new file scanner
    pub fn new(signature_db: Arc<SignatureDB>, config: ScanConfig) -> Self {
        // Parse YARA rules and extract patterns if enabled
        let signature_patterns = if config.enable_yara {
            Self::parse_signature_patterns(&signature_db)
        } else {
            Vec::new()
        };

        Self {
            signature_db,
            signature_patterns,
            scan_config: config,
        }
    }

    /// Parse YARA rules and extract string/hex patterns
    fn parse_signature_patterns(signature_db: &SignatureDB) -> Vec<SignaturePattern> {
        let rules = signature_db.get_all_yara_rules();

        if rules.is_empty() {
            log::warn!("No signature rules found in database");
            return Vec::new();
        }

        let mut patterns = Vec::new();

        for rule in rules {
            // Extract string patterns from YARA rule text
            let mut string_patterns = Vec::new();
            let mut hex_patterns = Vec::new();

            // Simple parsing: extract strings between quotes
            for line in rule.rule_text.lines() {
                let trimmed = line.trim();

                // Extract ASCII/wide strings (e.g., $s1 = "malware.exe")
                if let Some(start) = trimmed.find('"') {
                    if let Some(end) = trimmed[start + 1..].find('"') {
                        let pattern = &trimmed[start + 1..start + 1 + end];
                        string_patterns.push(pattern.to_string());
                    }
                }

                // Extract hex patterns (e.g., $h1 = { 4D 5A 90 00 })
                if trimmed.contains('{') && trimmed.contains('}') {
                    if let Some(start) = trimmed.find('{') {
                        if let Some(end) = trimmed[start..].find('}') {
                            let hex_str = &trimmed[start + 1..start + end];
                            let hex_bytes: Vec<u8> = hex_str
                                .split_whitespace()
                                .filter_map(|s| u8::from_str_radix(s, 16).ok())
                                .collect();

                            if !hex_bytes.is_empty() {
                                hex_patterns.push(hex_bytes);
                            }
                        }
                    }
                }
            }

            if !string_patterns.is_empty() || !hex_patterns.is_empty() {
                patterns.push(SignaturePattern {
                    name: rule.name.clone(),
                    category: rule.category.clone(),
                    patterns: string_patterns,
                    hex_patterns,
                });
            }
        }

        log::info!("Loaded {} signature patterns", patterns.len());
        patterns
    }

    /// Scan a file for malware
    pub fn scan_file(&self, path: &Path) -> Result<ScanResult, String> {
        let start_time = std::time::Instant::now();

        log::debug!("Scanning file: {:?}", path);

        // Check if file exists
        if !path.exists() {
            return Err(format!("File not found: {:?}", path));
        }

        // Get file metadata
        let metadata = std::fs::metadata(path)
            .map_err(|e| format!("Failed to get file metadata: {}", e))?;

        let file_size = metadata.len();

        // Check file size limit
        if file_size > self.scan_config.max_file_size {
            return Err(format!(
                "File too large: {} MB (max: {} MB)",
                file_size / 1024 / 1024,
                self.scan_config.max_file_size / 1024 / 1024
            ));
        }

        // Read file
        let mut file = File::open(path)
            .map_err(|e| format!("Failed to open file: {}", e))?;

        let mut file_bytes = Vec::new();
        file.read_to_end(&mut file_bytes)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        // Calculate file hash
        let file_hash = self.calculate_sha256(&file_bytes);

        // Initialize scan details
        let mut details = ScanDetails {
            hash_malicious: false,
            yara_matches: Vec::new(),
            ml_prediction: None,
            suspicious_indicators: Vec::new(),
            file_type: None,
            packer_detected: None,
        };

        // Detection results
        let mut is_malicious = false;
        let mut threat_name: Option<String> = None;
        let mut detection_method: Option<DetectionMethod> = None;
        let mut confidence = 0.0;

        // 1. Hash-based detection (fastest)
        if self.scan_config.enable_hash_check {
            if let Ok(hash_malicious) = self.signature_db.is_hash_malicious(&file_hash) {
                details.hash_malicious = hash_malicious;

                if hash_malicious {
                    is_malicious = true;
                    threat_name = Some("Known Malware".to_string());
                    detection_method = Some(DetectionMethod::Hash);
                    confidence = 1.0;

                    log::warn!("⚠️  Known malicious hash detected: {}", file_hash);

                    // Skip further scanning for known malware
                    let duration = start_time.elapsed().as_millis() as u64;

                    return Ok(ScanResult {
                        is_malicious,
                        threat_name,
                        detection_method: detection_method.unwrap(),
                        confidence,
                        file_hash,
                        file_size,
                        scan_duration_ms: duration,
                        details,
                    });
                }
            }
        }

        // 2. YARA signature scanning
        if self.scan_config.enable_yara {
            if let Ok(matches) = self.scan_yara(&file_bytes) {
                details.yara_matches = matches.clone();

                if !matches.is_empty() {
                    is_malicious = true;
                    threat_name = Some(format!("YARA: {}", matches[0]));
                    detection_method = Some(DetectionMethod::Yara {
                        rule_name: matches[0].clone(),
                        rule_category: "malware".to_string(), // TODO: Get actual category
                    });
                    confidence = 0.95; // High confidence for YARA matches

                    log::warn!("⚠️  YARA rule matched: {:?}", matches);
                }
            }
        }

        // 3. Machine learning detection
        if self.scan_config.enable_ml && !is_malicious {
            if let Ok(ml_score) = self.scan_ml(&file_bytes, path) {
                details.ml_prediction = Some(ml_score);

                if ml_score > 0.5 {
                    is_malicious = true;
                    threat_name = Some("ML: Suspicious Behavior".to_string());
                    detection_method = Some(DetectionMethod::MachineLearning {
                        model_name: "ensemble".to_string(),
                        probability: ml_score,
                    });
                    confidence = ml_score;

                    log::warn!("⚠️  ML detected malware (confidence: {:.1}%)", ml_score * 100.0);
                }
            }
        }

        // 4. Behavioral analysis
        if self.scan_config.enable_behavioral {
            let indicators = self.scan_behavioral(&file_bytes);
            details.suspicious_indicators = indicators.clone();

            // If we have multiple suspicious indicators and no other detection, flag it
            if indicators.len() >= 3 && !is_malicious {
                is_malicious = true;
                threat_name = Some("Behavioral: Multiple Suspicious Indicators".to_string());
                detection_method = Some(DetectionMethod::Behavioral {
                    suspicious_behaviors: indicators.clone(),
                });
                confidence = 0.7; // Medium confidence for behavioral

                log::warn!("⚠️  Behavioral analysis: {:?}", indicators);
            }
        }

        // Calculate scan duration
        let duration = start_time.elapsed().as_millis() as u64;

        log::debug!(
            "Scan complete: {:?} ({}ms) - {}",
            path,
            duration,
            if is_malicious { "MALICIOUS" } else { "CLEAN" }
        );

        Ok(ScanResult {
            is_malicious,
            threat_name,
            detection_method: detection_method.unwrap_or(DetectionMethod::Hash),
            confidence,
            file_hash,
            file_size,
            scan_duration_ms: duration,
            details,
        })
    }

    /// Calculate SHA256 hash of file
    fn calculate_sha256(&self, data: &[u8]) -> String {
        let mut hasher = Sha256::new();
        hasher.update(data);
        let result = hasher.finalize();
        format!("{:x}", result)
    }

    /// Scan with signature patterns
    fn scan_yara(&self, data: &[u8]) -> Result<Vec<String>, String> {
        if self.signature_patterns.is_empty() {
            log::debug!("No signature patterns loaded, skipping pattern scan");
            return Ok(Vec::new());
        }

        let mut matches = Vec::new();

        // Scan each pattern
        for pattern in &self.signature_patterns {
            let mut pattern_matches = 0;

            // Check string patterns
            for string_pattern in &pattern.patterns {
                let pattern_bytes = string_pattern.as_bytes();
                if self.find_pattern(data, pattern_bytes) {
                    pattern_matches += 1;
                }
            }

            // Check hex patterns
            for hex_pattern in &pattern.hex_patterns {
                if self.find_pattern(data, hex_pattern) {
                    pattern_matches += 1;
                }
            }

            // If at least 2 patterns matched (or 1 if only 1 pattern exists), consider it a match
            let required_matches = if pattern.patterns.len() + pattern.hex_patterns.len() > 2 {
                2
            } else {
                1
            };

            if pattern_matches >= required_matches {
                log::debug!("Signature match: {} (category: {})", pattern.name, pattern.category);
                matches.push(pattern.name.clone());
            }
        }

        Ok(matches)
    }

    /// Find pattern in data using Boyer-Moore-like sliding window
    fn find_pattern(&self, data: &[u8], pattern: &[u8]) -> bool {
        if pattern.is_empty() || data.len() < pattern.len() {
            return false;
        }

        // Simple sliding window search
        for i in 0..=data.len() - pattern.len() {
            if &data[i..i + pattern.len()] == pattern {
                return true;
            }
        }

        false
    }

    /// Scan with ML model
    fn scan_ml(&self, data: &[u8], path: &Path) -> Result<f32, String> {
        // TODO: Implement ML inference
        // 1. Extract features from file
        // 2. Load ONNX model
        // 3. Run inference
        // 4. Return probability

        // For now, return 0.0 (not implemented)
        Ok(0.0)
    }

    /// Behavioral analysis
    fn scan_behavioral(&self, data: &[u8]) -> Vec<String> {
        let mut indicators = Vec::new();

        // Check for high entropy (possible encryption/packing)
        let entropy = self.calculate_entropy(data);
        if entropy > 7.0 {
            indicators.push(format!("High entropy: {:.2}", entropy));
        }

        // Check for suspicious strings
        let suspicious_strings = self.find_suspicious_strings(data);
        if !suspicious_strings.is_empty() {
            indicators.push(format!("Suspicious strings: {}", suspicious_strings.len()));
        }

        // Check for PE characteristics (Windows executables)
        if data.len() > 2 && data[0] == 0x4D && data[1] == 0x5A {
            // MZ header (PE file)
            if let Some(pe_indicators) = self.analyze_pe(data) {
                indicators.extend(pe_indicators);
            }
        }

        // Check for ELF characteristics (Linux executables)
        if data.len() > 4 && data[0] == 0x7F && data[1] == 0x45 && data[2] == 0x4C && data[3] == 0x46 {
            // ELF header
            if let Some(elf_indicators) = self.analyze_elf(data) {
                indicators.extend(elf_indicators);
            }
        }

        indicators
    }

    /// Calculate Shannon entropy
    fn calculate_entropy(&self, data: &[u8]) -> f64 {
        if data.is_empty() {
            return 0.0;
        }

        let mut byte_counts = [0u64; 256];
        for &byte in data {
            byte_counts[byte as usize] += 1;
        }

        let len = data.len() as f64;
        let mut entropy = 0.0;

        for &count in &byte_counts {
            if count > 0 {
                let probability = count as f64 / len;
                entropy -= probability * probability.log2();
            }
        }

        entropy
    }

    /// Find suspicious strings
    fn find_suspicious_strings(&self, data: &[u8]) -> Vec<String> {
        let mut suspicious = Vec::new();

        // Convert to string (ASCII only)
        let text = String::from_utf8_lossy(data);

        // Suspicious keywords
        let keywords = [
            "cmd.exe", "powershell", "CreateRemoteThread",
            "WriteProcessMemory", "VirtualAlloc", "GetProcAddress",
            "LoadLibrary", "ShellExecute", "WinExec",
            "RegSetValue", "CreateProcess", "URLDownloadToFile",
        ];

        for keyword in keywords {
            if text.contains(keyword) {
                suspicious.push(keyword.to_string());
            }
        }

        suspicious
    }

    /// Analyze PE file
    fn analyze_pe(&self, data: &[u8]) -> Option<Vec<String>> {
        let mut indicators = Vec::new();

        // TODO: Full PE analysis with pefile crate
        // For now, basic checks

        // Check for suspicious sections
        if let Some(sections) = self.get_pe_sections(data) {
            for section in sections {
                // High entropy sections (possibly packed)
                if section.entropy > 7.0 {
                    indicators.push(format!("High entropy section: {}", section.name));
                }

                // Executable writable sections (code injection)
                if section.executable && section.writable {
                    indicators.push(format!("Executable+Writable section: {}", section.name));
                }
            }
        }

        if indicators.is_empty() {
            None
        } else {
            Some(indicators)
        }
    }

    /// Get PE sections (simplified)
    fn get_pe_sections(&self, data: &[u8]) -> Option<Vec<PESection>> {
        // TODO: Implement proper PE parsing
        None
    }

    /// Analyze ELF file
    fn analyze_elf(&self, data: &[u8]) -> Option<Vec<String>> {
        let mut indicators = Vec::new();

        // TODO: Full ELF analysis

        if indicators.is_empty() {
            None
        } else {
            Some(indicators)
        }
    }

    /// Batch scan multiple files
    pub fn scan_files(&self, paths: Vec<&Path>) -> Vec<Result<ScanResult, String>> {
        paths.into_iter().map(|path| self.scan_file(path)).collect()
    }
}

/// PE section information
#[derive(Debug)]
struct PESection {
    name: String,
    entropy: f64,
    executable: bool,
    writable: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_entropy() {
        let scanner = FileScanner::new(
            Arc::new(SignatureDB::new(":memory:").unwrap()),
            ScanConfig::default()
        );

        // Low entropy (repeated data)
        let low_entropy_data = vec![0x41; 1000]; // "AAAA..."
        let entropy = scanner.calculate_entropy(&low_entropy_data);
        assert!(entropy < 1.0);

        // High entropy (random data)
        let high_entropy_data: Vec<u8> = (0..256).collect();
        let entropy = scanner.calculate_entropy(&high_entropy_data);
        assert!(entropy > 7.0);
    }

    #[test]
    fn test_suspicious_strings() {
        let scanner = FileScanner::new(
            Arc::new(SignatureDB::new(":memory:").unwrap()),
            ScanConfig::default()
        );

        let data = b"This file contains cmd.exe and powershell.exe";
        let suspicious = scanner.find_suspicious_strings(data);

        assert_eq!(suspicious.len(), 2);
        assert!(suspicious.contains(&"cmd.exe".to_string()));
        assert!(suspicious.contains(&"powershell".to_string()));
    }
}
