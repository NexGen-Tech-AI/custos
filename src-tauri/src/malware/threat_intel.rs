/*!
 * Threat Intelligence Integration
 *
 * Provides real-time threat intelligence integration:
 * - STIX/TAXII feed consumption
 * - IOC (Indicators of Compromise) management
 * - File/IP/Domain reputation services
 * - APT group correlation
 * - Emerging threat tracking
 * - Automatic signature updates
 * - Threat feed aggregation
 *
 * Integrates with major threat intelligence sources:
 * - AlienVault OTX, MISP, ThreatConnect
 * - VirusTotal, AbuseIPDB
 * - Custom feeds and YARA rules
 */

use serde::{Serialize, Deserialize};
use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

/// Indicator of Compromise (IOC) types
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum IocType {
    /// File hash (MD5, SHA1, SHA256)
    FileHash,

    /// IP address
    IpAddress,

    /// Domain name
    Domain,

    /// URL
    Url,

    /// Email address
    Email,

    /// Registry key (Windows)
    RegistryKey,

    /// Mutex name
    Mutex,

    /// User agent string
    UserAgent,

    /// Certificate thumbprint
    Certificate,
}

/// IOC entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Ioc {
    pub ioc_type: IocType,
    pub value: String,
    pub threat_level: ThreatLevel,
    pub confidence: f32, // 0.0 - 1.0
    pub source: String,
    pub first_seen: i64,
    pub last_seen: i64,
    pub tags: Vec<String>,
    pub description: String,
    pub mitre_techniques: Vec<String>,
    pub associated_malware: Vec<String>,
    pub apt_groups: Vec<String>,
}

/// Threat level classification
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum ThreatLevel {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

/// Threat intelligence feed source
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatFeed {
    pub name: String,
    pub url: String,
    pub feed_type: FeedType,
    pub enabled: bool,
    pub last_update: i64,
    pub update_interval: u64, // seconds
    pub ioc_count: usize,
}

/// Threat feed types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FeedType {
    /// STIX/TAXII format
    Stix,

    /// MISP format
    Misp,

    /// CSV/TSV format
    Csv,

    /// JSON format
    Json,

    /// Custom format
    Custom,
}

/// APT (Advanced Persistent Threat) group
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AptGroup {
    pub name: String,
    pub aliases: Vec<String>,
    pub country: Option<String>,
    pub targets: Vec<String>,
    pub techniques: Vec<String>,
    pub malware_families: Vec<String>,
    pub first_seen: i64,
    pub last_activity: i64,
    pub description: String,
}

/// Threat intelligence match result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatMatch {
    pub ioc: Ioc,
    pub matched_value: String,
    pub match_type: IocType,
    pub timestamp: i64,
    pub context: String,
}

/// Reputation score
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReputationScore {
    pub value: String,
    pub score: f32, // 0.0 (malicious) to 100.0 (benign)
    pub sources: Vec<String>,
    pub last_checked: i64,
    pub verdict: ReputationVerdict,
}

/// Reputation verdict
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ReputationVerdict {
    Malicious,
    Suspicious,
    Unknown,
    Clean,
}

/// Threat intelligence engine
pub struct ThreatIntelEngine {
    iocs: HashMap<IocType, HashMap<String, Ioc>>,
    feeds: Vec<ThreatFeed>,
    apt_groups: HashMap<String, AptGroup>,
    matches: Vec<ThreatMatch>,
    reputation_cache: HashMap<String, ReputationScore>,
    config: ThreatIntelConfig,
}

/// Threat intelligence configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatIntelConfig {
    pub enabled: bool,
    pub auto_update: bool,
    pub update_interval: u64, // seconds
    pub max_iocs: usize,
    pub max_cache_size: usize,
    pub min_confidence: f32,
    pub enable_reputation_check: bool,
}

impl Default for ThreatIntelConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            auto_update: true,
            update_interval: 3600, // 1 hour
            max_iocs: 1_000_000,
            max_cache_size: 100_000,
            min_confidence: 0.5,
            enable_reputation_check: true,
        }
    }
}

impl ThreatIntelEngine {
    /// Create new threat intelligence engine
    pub fn new(config: ThreatIntelConfig) -> Self {
        let mut engine = Self {
            iocs: HashMap::new(),
            feeds: Vec::new(),
            apt_groups: HashMap::new(),
            matches: Vec::new(),
            reputation_cache: HashMap::new(),
            config,
        };

        // Initialize IOC storage
        engine.iocs.insert(IocType::FileHash, HashMap::new());
        engine.iocs.insert(IocType::IpAddress, HashMap::new());
        engine.iocs.insert(IocType::Domain, HashMap::new());
        engine.iocs.insert(IocType::Url, HashMap::new());

        // Load default feeds
        engine.load_default_feeds();

        // Load APT groups
        engine.load_apt_groups();

        log::info!("Threat intelligence engine initialized");

        engine
    }

    /// Add IOC to the database
    pub fn add_ioc(&mut self, ioc: Ioc) -> Result<(), String> {
        if ioc.confidence < self.config.min_confidence {
            return Err("IOC confidence below minimum threshold".to_string());
        }

        let ioc_store = self.iocs.entry(ioc.ioc_type.clone())
            .or_insert_with(HashMap::new);

        // Check max IOCs limit
        if ioc_store.len() >= self.config.max_iocs {
            log::warn!("Max IOCs limit reached, removing oldest");
            // TODO: Implement LRU eviction
        }

        ioc_store.insert(ioc.value.clone(), ioc);

        Ok(())
    }

    /// Check if value matches any IOC
    pub fn check_ioc(&mut self, ioc_type: &IocType, value: &str) -> Option<ThreatMatch> {
        let ioc_store = self.iocs.get(ioc_type)?;

        if let Some(ioc) = ioc_store.get(value) {
            let threat_match = ThreatMatch {
                ioc: ioc.clone(),
                matched_value: value.to_string(),
                match_type: ioc_type.clone(),
                timestamp: Self::current_timestamp(),
                context: String::new(),
            };

            log::warn!(
                "⚠️  Threat intelligence match: {} ({:?}) - Threat Level: {:?}",
                value,
                ioc_type,
                ioc.threat_level
            );

            self.matches.push(threat_match.clone());

            return Some(threat_match);
        }

        None
    }

    /// Get reputation score for a value
    pub fn get_reputation(&mut self, value: &str) -> ReputationScore {
        // Check cache first
        if let Some(cached) = self.reputation_cache.get(value) {
            let age = Self::current_timestamp() - cached.last_checked;
            if age < 3600 {  // 1 hour cache
                return cached.clone();
            }
        }

        // Calculate reputation based on IOCs
        let mut score = 100.0; // Start with clean score
        let mut sources = Vec::new();
        let mut verdict = ReputationVerdict::Unknown;

        // Check against all IOC types
        for (ioc_type, ioc_store) in &self.iocs {
            if let Some(ioc) = ioc_store.get(value) {
                score = match ioc.threat_level {
                    ThreatLevel::Critical => 0.0,
                    ThreatLevel::High => 20.0,
                    ThreatLevel::Medium => 40.0,
                    ThreatLevel::Low => 60.0,
                    ThreatLevel::Info => 80.0,
                };

                sources.push(ioc.source.clone());

                verdict = if score <= 20.0 {
                    ReputationVerdict::Malicious
                } else if score <= 50.0 {
                    ReputationVerdict::Suspicious
                } else {
                    ReputationVerdict::Unknown
                };

                break;
            }
        }

        if sources.is_empty() {
            verdict = ReputationVerdict::Clean;
            sources.push("Local analysis".to_string());
        }

        let reputation = ReputationScore {
            value: value.to_string(),
            score,
            sources,
            last_checked: Self::current_timestamp(),
            verdict,
        };

        // Cache the result
        if self.reputation_cache.len() < self.config.max_cache_size {
            self.reputation_cache.insert(value.to_string(), reputation.clone());
        }

        reputation
    }

    /// Update threat feeds
    pub fn update_feeds(&mut self) -> Result<usize, String> {
        if !self.config.auto_update {
            return Ok(0);
        }

        let mut total_updated = 0;

        // Collect indices of feeds that need updating
        let mut feeds_to_update = Vec::new();
        for (idx, feed) in self.feeds.iter().enumerate() {
            if !feed.enabled {
                continue;
            }

            let age = Self::current_timestamp() - feed.last_update;
            if age < feed.update_interval as i64 {
                continue;
            }

            feeds_to_update.push(idx);
        }

        // Update each feed
        for idx in feeds_to_update {
            let feed_clone = self.feeds[idx].clone();

            log::info!("Updating threat feed: {}", feed_clone.name);

            match self.fetch_feed(&feed_clone) {
                Ok(iocs) => {
                    for ioc in iocs {
                        if let Err(e) = self.add_ioc(ioc) {
                            log::warn!("Failed to add IOC: {}", e);
                        } else {
                            total_updated += 1;
                        }
                    }

                    self.feeds[idx].last_update = Self::current_timestamp();

                    log::info!("Updated feed {}: {} new IOCs", feed_clone.name, total_updated);
                }
                Err(e) => {
                    log::error!("Failed to update feed {}: {}", feed_clone.name, e);
                }
            }
        }

        Ok(total_updated)
    }

    /// Fetch threat feed (stub - would implement actual fetching)
    fn fetch_feed(&self, feed: &ThreatFeed) -> Result<Vec<Ioc>, String> {
        // TODO: Implement actual feed fetching
        // This would parse STIX, MISP, CSV, JSON formats
        // For now, return empty
        Ok(Vec::new())
    }

    /// Load default threat feeds
    fn load_default_feeds(&mut self) {
        self.feeds.push(ThreatFeed {
            name: "AlienVault OTX".to_string(),
            url: "https://otx.alienvault.com/api/v1/pulses/subscribed".to_string(),
            feed_type: FeedType::Json,
            enabled: true,
            last_update: 0,
            update_interval: 3600,
            ioc_count: 0,
        });

        self.feeds.push(ThreatFeed {
            name: "AbuseIPDB".to_string(),
            url: "https://api.abuseipdb.com/api/v2/blacklist".to_string(),
            feed_type: FeedType::Json,
            enabled: true,
            last_update: 0,
            update_interval: 86400, // 24 hours
            ioc_count: 0,
        });

        self.feeds.push(ThreatFeed {
            name: "Malware Bazaar".to_string(),
            url: "https://bazaar.abuse.ch/export/csv/recent/".to_string(),
            feed_type: FeedType::Csv,
            enabled: true,
            last_update: 0,
            update_interval: 3600,
            ioc_count: 0,
        });

        log::info!("Loaded {} default threat feeds", self.feeds.len());
    }

    /// Load APT group information
    fn load_apt_groups(&mut self) {
        // APT28 (Fancy Bear)
        self.apt_groups.insert("APT28".to_string(), AptGroup {
            name: "APT28".to_string(),
            aliases: vec!["Fancy Bear".to_string(), "Sofacy".to_string(), "Pawn Storm".to_string()],
            country: Some("Russia".to_string()),
            targets: vec!["Government".to_string(), "Military".to_string(), "Media".to_string()],
            techniques: vec!["T1566".to_string(), "T1059".to_string(), "T1078".to_string()],
            malware_families: vec!["X-Agent".to_string(), "Sofacy".to_string()],
            first_seen: 1262304000, // 2010
            last_activity: Self::current_timestamp(),
            description: "Russian cyber espionage group".to_string(),
        });

        // APT29 (Cozy Bear)
        self.apt_groups.insert("APT29".to_string(), AptGroup {
            name: "APT29".to_string(),
            aliases: vec!["Cozy Bear".to_string(), "The Dukes".to_string()],
            country: Some("Russia".to_string()),
            targets: vec!["Government".to_string(), "Think tanks".to_string()],
            techniques: vec!["T1566".to_string(), "T1055".to_string()],
            malware_families: vec!["WellMess".to_string(), "WellMail".to_string()],
            first_seen: 1262304000,
            last_activity: Self::current_timestamp(),
            description: "Russian intelligence-linked APT".to_string(),
        });

        // Lazarus Group
        self.apt_groups.insert("Lazarus".to_string(), AptGroup {
            name: "Lazarus Group".to_string(),
            aliases: vec!["Hidden Cobra".to_string(), "ZINC".to_string()],
            country: Some("North Korea".to_string()),
            targets: vec!["Financial".to_string(), "Cryptocurrency".to_string(), "Media".to_string()],
            techniques: vec!["T1566".to_string(), "T1486".to_string(), "T1071".to_string()],
            malware_families: vec!["WannaCry".to_string(), "HOPLIGHT".to_string()],
            first_seen: 1293840000, // 2011
            last_activity: Self::current_timestamp(),
            description: "North Korean state-sponsored group".to_string(),
        });

        log::info!("Loaded {} APT group profiles", self.apt_groups.len());
    }

    /// Correlate threat with APT groups
    pub fn correlate_apt(&self, ioc: &Ioc) -> Vec<String> {
        let mut matched_groups = Vec::new();

        for (group_name, group) in &self.apt_groups {
            // Check if IOC's malware families match APT group
            for malware in &ioc.associated_malware {
                if group.malware_families.contains(malware) {
                    matched_groups.push(group_name.clone());
                    break;
                }
            }

            // Check MITRE techniques
            for technique in &ioc.mitre_techniques {
                if group.techniques.contains(technique) {
                    if !matched_groups.contains(group_name) {
                        matched_groups.push(group_name.clone());
                    }
                    break;
                }
            }
        }

        matched_groups
    }

    /// Get all threat matches
    pub fn get_matches(&self) -> &[ThreatMatch] {
        &self.matches
    }

    /// Get recent threat matches
    pub fn get_recent_matches(&self, count: usize) -> Vec<ThreatMatch> {
        self.matches.iter()
            .rev()
            .take(count)
            .cloned()
            .collect()
    }

    /// Clear old matches
    pub fn clear_old_matches(&mut self, older_than_seconds: i64) {
        let cutoff = Self::current_timestamp() - older_than_seconds;
        self.matches.retain(|m| m.timestamp > cutoff);
    }

    /// Get statistics
    pub fn get_stats(&self) -> ThreatIntelStats {
        let mut ioc_counts = HashMap::new();

        for (ioc_type, ioc_store) in &self.iocs {
            ioc_counts.insert(format!("{:?}", ioc_type), ioc_store.len());
        }

        ThreatIntelStats {
            total_iocs: self.iocs.values().map(|s| s.len()).sum(),
            ioc_counts,
            total_feeds: self.feeds.len(),
            active_feeds: self.feeds.iter().filter(|f| f.enabled).count(),
            total_matches: self.matches.len(),
            apt_groups: self.apt_groups.len(),
            cache_size: self.reputation_cache.len(),
        }
    }

    /// Get current Unix timestamp
    fn current_timestamp() -> i64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64
    }
}

/// Threat intelligence statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct ThreatIntelStats {
    pub total_iocs: usize,
    pub ioc_counts: HashMap<String, usize>,
    pub total_feeds: usize,
    pub active_feeds: usize,
    pub total_matches: usize,
    pub apt_groups: usize,
    pub cache_size: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_threat_intel_creation() {
        let config = ThreatIntelConfig::default();
        let engine = ThreatIntelEngine::new(config);

        let stats = engine.get_stats();
        assert!(stats.total_feeds > 0);
        assert!(stats.apt_groups > 0);
    }

    #[test]
    fn test_ioc_addition() {
        let config = ThreatIntelConfig::default();
        let mut engine = ThreatIntelEngine::new(config);

        let ioc = Ioc {
            ioc_type: IocType::IpAddress,
            value: "1.2.3.4".to_string(),
            threat_level: ThreatLevel::High,
            confidence: 0.95,
            source: "Test".to_string(),
            first_seen: 0,
            last_seen: 0,
            tags: vec!["malware".to_string()],
            description: "Test IOC".to_string(),
            mitre_techniques: vec![],
            associated_malware: vec![],
            apt_groups: vec![],
        };

        assert!(engine.add_ioc(ioc).is_ok());
    }

    #[test]
    fn test_ioc_checking() {
        let config = ThreatIntelConfig::default();
        let mut engine = ThreatIntelEngine::new(config);

        let ioc = Ioc {
            ioc_type: IocType::Domain,
            value: "evil.com".to_string(),
            threat_level: ThreatLevel::Critical,
            confidence: 1.0,
            source: "Test".to_string(),
            first_seen: 0,
            last_seen: 0,
            tags: vec![],
            description: "Malicious domain".to_string(),
            mitre_techniques: vec![],
            associated_malware: vec![],
            apt_groups: vec![],
        };

        engine.add_ioc(ioc).unwrap();

        let result = engine.check_ioc(&IocType::Domain, "evil.com");
        assert!(result.is_some());
    }

    #[test]
    fn test_reputation_check() {
        let config = ThreatIntelConfig::default();
        let mut engine = ThreatIntelEngine::new(config);

        let reputation = engine.get_reputation("google.com");
        assert_eq!(reputation.verdict, ReputationVerdict::Clean);
        assert!(reputation.score > 80.0);
    }
}
