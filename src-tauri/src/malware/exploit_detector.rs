/*!
 * Advanced Exploit Detection Engine
 *
 * Detects sophisticated exploitation techniques:
 * - ROP (Return-Oriented Programming) chains
 * - Heap spraying
 * - Stack smashing / buffer overflows
 * - Use-After-Free exploitation
 * - Integer overflow exploitation
 * - Format string exploits
 * - DEP/ASLR bypass attempts
 * - Shellcode injection patterns
 * - JIT spraying (browser exploits)
 * - Type confusion exploits
 *
 * Provides real-time exploit primitive detection to prevent zero-day exploitation.
 */

use serde::{Serialize, Deserialize};
use std::collections::{HashMap, VecDeque};
use std::time::{SystemTime, UNIX_EPOCH};

/// Exploit detection result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitDetection {
    pub process_id: u32,
    pub process_name: String,
    pub exploit_type: ExploitType,
    pub severity: String, // "critical", "high", "medium", "low"
    pub confidence: f32, // 0.0 - 1.0
    pub timestamp: i64,
    pub mitre_technique: Option<String>,
    pub indicators: Vec<ExploitIndicator>,
    pub description: String,
    pub memory_address: Option<u64>,
    pub exploitation_target: Option<String>,
}

/// Types of exploits
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum ExploitType {
    /// ROP chain detected
    RopChain,

    /// Heap spray detected
    HeapSpray,

    /// Stack smashing / buffer overflow
    BufferOverflow,

    /// Use-After-Free exploitation
    UseAfterFree,

    /// Integer overflow/underflow
    IntegerOverflow,

    /// Format string exploit
    FormatString,

    /// DEP bypass attempt
    DepBypass,

    /// ASLR bypass attempt
    AslrBypass,

    /// Shellcode injection
    ShellcodeInjection,

    /// JIT spray (browser exploit)
    JitSpray,

    /// Type confusion exploit
    TypeConfusion,

    /// Double free vulnerability
    DoubleFree,

    /// Stack pivot
    StackPivot,

    /// Virtual table hijacking
    VtableHijacking,
}

/// Exploit indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitIndicator {
    pub indicator_type: String,
    pub value: String,
    pub weight: f32,
    pub timestamp: i64,
}

/// Memory pattern for ROP detection
#[derive(Debug, Clone)]
struct RopPattern {
    gadget_count: usize,
    stack_addresses: Vec<u64>,
    potential_gadgets: Vec<u64>,
    first_detected: i64,
}

/// Heap allocation tracking
#[derive(Debug, Clone)]
struct HeapAllocation {
    address: u64,
    size: usize,
    timestamp: i64,
    freed: bool,
}

/// Exploit detector configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitDetectorConfig {
    /// Enable ROP chain detection
    pub detect_rop: bool,

    /// Enable heap spray detection
    pub detect_heap_spray: bool,

    /// Enable stack smashing detection
    pub detect_buffer_overflow: bool,

    /// Enable Use-After-Free detection
    pub detect_uaf: bool,

    /// Minimum ROP gadgets to trigger alert
    pub rop_gadget_threshold: usize,

    /// Heap spray allocation threshold
    pub heap_spray_threshold: usize,

    /// Maximum heap allocation size (bytes) before flagging
    pub max_heap_allocation: usize,
}

impl Default for ExploitDetectorConfig {
    fn default() -> Self {
        Self {
            detect_rop: true,
            detect_heap_spray: true,
            detect_buffer_overflow: true,
            detect_uaf: true,
            rop_gadget_threshold: 5,
            heap_spray_threshold: 100,
            max_heap_allocation: 100 * 1024 * 1024, // 100 MB
        }
    }
}

/// Exploit detector
pub struct ExploitDetector {
    config: ExploitDetectorConfig,
    detections: Vec<ExploitDetection>,
    rop_patterns: HashMap<u32, RopPattern>, // pid -> ROP pattern
    heap_allocations: HashMap<u32, Vec<HeapAllocation>>, // pid -> allocations
    freed_addresses: HashMap<u32, Vec<u64>>, // pid -> freed addresses
}

impl ExploitDetector {
    /// Create new exploit detector
    pub fn new(config: ExploitDetectorConfig) -> Self {
        let detector = Self {
            config,
            detections: Vec::new(),
            rop_patterns: HashMap::new(),
            heap_allocations: HashMap::new(),
            freed_addresses: HashMap::new(),
        };

        log::info!("Exploit detector initialized");

        detector
    }

    /// Start exploit monitoring
    pub fn start_monitoring(&mut self) -> Result<(), String> {
        log::info!("Starting exploit detection");

        // TODO: Set up low-level monitoring:
        // - Linux: eBPF probes on memory operations, USDT probes
        // - Windows: ETW for heap operations, exception handling
        // - Hardware: Intel PT (Processor Trace) for control flow

        Ok(())
    }

    /// Stop exploit monitoring
    pub fn stop_monitoring(&mut self) {
        log::info!("Stopping exploit detection");
        // TODO: Clean up monitoring hooks
    }

    /// Analyze memory region for ROP gadgets
    pub fn analyze_memory_for_rop(
        &mut self,
        pid: u32,
        process_name: String,
        memory_data: &[u8],
        base_address: u64,
    ) {
        if !self.config.detect_rop {
            return;
        }

        // Detect ROP gadgets (simplified - real implementation would use capstone/similar)
        let mut gadget_count = 0;
        let mut potential_gadgets = Vec::new();

        // Look for "ret" instructions (0xC3) and gadget patterns
        for (i, window) in memory_data.windows(2).enumerate() {
            // Detect "ret" instruction
            if window[0] == 0xC3 {
                gadget_count += 1;
                potential_gadgets.push(base_address + i as u64);
            }

            // Detect "pop; ret" pattern
            if window.len() >= 2 && (window[0] >= 0x58 && window[0] <= 0x5F) && window[1] == 0xC3 {
                gadget_count += 1;
                potential_gadgets.push(base_address + i as u64);
            }
        }

        if gadget_count >= self.config.rop_gadget_threshold {
            self.detect_rop_chain(pid, process_name, gadget_count, potential_gadgets);
        }
    }

    /// Record heap allocation
    pub fn record_heap_allocation(
        &mut self,
        pid: u32,
        process_name: String,
        address: u64,
        size: usize,
    ) {
        let timestamp = Self::current_timestamp();

        // Track allocation
        let allocations = self.heap_allocations.entry(pid).or_insert_with(Vec::new);
        allocations.push(HeapAllocation {
            address,
            size,
            timestamp,
            freed: false,
        });

        // Detect heap spray
        if self.config.detect_heap_spray {
            let recent_allocs = allocations.iter()
                .filter(|a| !a.freed && timestamp - a.timestamp < 10)
                .count();

            if recent_allocs >= self.config.heap_spray_threshold {
                self.detect_heap_spray(pid, &process_name, recent_allocs);
            }
        }

        // Detect abnormally large allocation
        if size > self.config.max_heap_allocation {
            log::warn!(
                "⚠️  Abnormally large heap allocation: {} (PID {}) - {} bytes at 0x{:x}",
                process_name,
                pid,
                size,
                address
            );
        }

        // Cleanup old allocations
        self.cleanup_old_allocations(pid);
    }

    /// Record heap free
    pub fn record_heap_free(
        &mut self,
        pid: u32,
        process_name: String,
        address: u64,
    ) {
        // Track freed address
        let freed = self.freed_addresses.entry(pid).or_insert_with(Vec::new);

        // Check for double free
        if freed.contains(&address) {
            self.detect_double_free(pid, process_name, address);
            return;
        }

        freed.push(address);

        // Mark allocation as freed
        if let Some(allocations) = self.heap_allocations.get_mut(&pid) {
            for alloc in allocations.iter_mut() {
                if alloc.address == address {
                    alloc.freed = true;
                    break;
                }
            }
        }

        // Cleanup old freed addresses
        if freed.len() > 1000 {
            freed.drain(0..500);
        }
    }

    /// Record heap access (to detect Use-After-Free)
    pub fn record_heap_access(
        &mut self,
        pid: u32,
        process_name: String,
        address: u64,
    ) {
        if !self.config.detect_uaf {
            return;
        }

        // Check if accessing freed memory
        if let Some(freed) = self.freed_addresses.get(&pid) {
            if freed.contains(&address) {
                self.detect_use_after_free(pid, process_name, address);
            }
        }
    }

    /// Detect stack overflow
    pub fn detect_stack_overflow(
        &mut self,
        pid: u32,
        process_name: String,
        stack_pointer: u64,
        stack_limit: u64,
    ) {
        if !self.config.detect_buffer_overflow {
            return;
        }

        if stack_pointer > stack_limit {
            log::warn!(
                "⚠️  Stack overflow detected: {} (PID {}) - SP: 0x{:x}, Limit: 0x{:x}",
                process_name,
                pid,
                stack_pointer,
                stack_limit
            );

            self.create_detection(
                pid,
                process_name,
                ExploitType::BufferOverflow,
                95.0,
                0.90,
                "T1203", // Exploitation for Client Execution
                vec![
                    ExploitIndicator {
                        indicator_type: "stack_overflow".to_string(),
                        value: format!("SP exceeded limit: 0x{:x} > 0x{:x}", stack_pointer, stack_limit),
                        weight: 50.0,
                        timestamp: Self::current_timestamp(),
                    },
                ],
                "Stack overflow / buffer overflow detected".to_string(),
                Some(stack_pointer),
                Some("Stack".to_string()),
            );
        }
    }

    /// Detect ROP chain
    fn detect_rop_chain(
        &mut self,
        pid: u32,
        process_name: String,
        gadget_count: usize,
        potential_gadgets: Vec<u64>,
    ) {
        log::warn!(
            "⚠️  ROP chain detected: {} (PID {}) - {} gadgets found",
            process_name,
            pid,
            gadget_count
        );

        self.create_detection(
            pid,
            process_name,
            ExploitType::RopChain,
            90.0,
            0.85,
            "T1203", // Exploitation for Client Execution
            vec![
                ExploitIndicator {
                    indicator_type: "rop_gadgets".to_string(),
                    value: format!("{} ROP gadgets detected", gadget_count),
                    weight: 45.0,
                    timestamp: Self::current_timestamp(),
                },
                ExploitIndicator {
                    indicator_type: "gadget_addresses".to_string(),
                    value: format!("First 5: {:x?}", &potential_gadgets[..5.min(potential_gadgets.len())]),
                    weight: 20.0,
                    timestamp: Self::current_timestamp(),
                },
            ],
            format!("ROP chain detected with {} gadgets", gadget_count),
            potential_gadgets.first().copied(),
            Some("Memory".to_string()),
        );
    }

    /// Detect heap spray
    fn detect_heap_spray(
        &mut self,
        pid: u32,
        process_name: &str,
        allocation_count: usize,
    ) {
        log::warn!(
            "⚠️  Heap spray detected: {} (PID {}) - {} allocations in 10s",
            process_name,
            pid,
            allocation_count
        );

        self.create_detection(
            pid,
            process_name.to_string(),
            ExploitType::HeapSpray,
            85.0,
            0.82,
            "T1203", // Exploitation for Client Execution
            vec![
                ExploitIndicator {
                    indicator_type: "rapid_heap_allocation".to_string(),
                    value: format!("{} heap allocations in 10 seconds", allocation_count),
                    weight: 40.0,
                    timestamp: Self::current_timestamp(),
                },
            ],
            format!("Heap spray detected ({} allocations)", allocation_count),
            None,
            Some("Heap".to_string()),
        );
    }

    /// Detect Use-After-Free
    fn detect_use_after_free(
        &mut self,
        pid: u32,
        process_name: String,
        address: u64,
    ) {
        log::warn!(
            "⚠️  Use-After-Free detected: {} (PID {}) accessing freed memory at 0x{:x}",
            process_name,
            pid,
            address
        );

        self.create_detection(
            pid,
            process_name,
            ExploitType::UseAfterFree,
            92.0,
            0.88,
            "T1203", // Exploitation for Client Execution
            vec![
                ExploitIndicator {
                    indicator_type: "uaf_access".to_string(),
                    value: format!("Access to freed memory at 0x{:x}", address),
                    weight: 48.0,
                    timestamp: Self::current_timestamp(),
                },
            ],
            format!("Use-After-Free at address 0x{:x}", address),
            Some(address),
            Some("Heap".to_string()),
        );
    }

    /// Detect double free
    fn detect_double_free(
        &mut self,
        pid: u32,
        process_name: String,
        address: u64,
    ) {
        log::warn!(
            "⚠️  Double free detected: {} (PID {}) freeing 0x{:x} twice",
            process_name,
            pid,
            address
        );

        self.create_detection(
            pid,
            process_name,
            ExploitType::DoubleFree,
            88.0,
            0.90,
            "T1203", // Exploitation for Client Execution
            vec![
                ExploitIndicator {
                    indicator_type: "double_free".to_string(),
                    value: format!("Double free at 0x{:x}", address),
                    weight: 45.0,
                    timestamp: Self::current_timestamp(),
                },
            ],
            format!("Double free at address 0x{:x}", address),
            Some(address),
            Some("Heap".to_string()),
        );
    }

    /// Create exploit detection
    fn create_detection(
        &mut self,
        pid: u32,
        process_name: String,
        exploit_type: ExploitType,
        severity_score: f32,
        confidence: f32,
        mitre_technique: &str,
        indicators: Vec<ExploitIndicator>,
        description: String,
        memory_address: Option<u64>,
        exploitation_target: Option<String>,
    ) {
        let severity = if severity_score >= 90.0 {
            "critical"
        } else if severity_score >= 70.0 {
            "high"
        } else if severity_score >= 50.0 {
            "medium"
        } else {
            "low"
        };

        let detection = ExploitDetection {
            process_id: pid,
            process_name,
            exploit_type,
            severity: severity.to_string(),
            confidence,
            timestamp: Self::current_timestamp(),
            mitre_technique: Some(mitre_technique.to_string()),
            indicators,
            description,
            memory_address,
            exploitation_target,
        };

        self.detections.push(detection);
    }

    /// Get all detections
    pub fn get_detections(&self) -> &[ExploitDetection] {
        &self.detections
    }

    /// Get recent detections
    pub fn get_recent_detections(&self, count: usize) -> Vec<ExploitDetection> {
        self.detections.iter()
            .rev()
            .take(count)
            .cloned()
            .collect()
    }

    /// Get detections by exploit type
    pub fn get_detections_by_type(&self, exploit_type: &ExploitType) -> Vec<ExploitDetection> {
        self.detections.iter()
            .filter(|d| &d.exploit_type == exploit_type)
            .cloned()
            .collect()
    }

    /// Clear old detections
    pub fn clear_old_detections(&mut self, older_than_seconds: i64) {
        let cutoff_time = Self::current_timestamp() - older_than_seconds;
        self.detections.retain(|d| d.timestamp > cutoff_time);
    }

    /// Get exploit detection statistics
    pub fn get_stats(&self) -> ExploitStats {
        let mut stats = ExploitStats {
            total_detections: self.detections.len(),
            by_exploit_type: HashMap::new(),
            by_severity: HashMap::new(),
            critical_count: 0,
            rop_detections: 0,
            heap_spray_detections: 0,
            uaf_detections: 0,
        };

        for detection in &self.detections {
            *stats.by_exploit_type.entry(format!("{:?}", detection.exploit_type)).or_insert(0) += 1;
            *stats.by_severity.entry(detection.severity.clone()).or_insert(0) += 1;

            if detection.severity == "critical" {
                stats.critical_count += 1;
            }

            match detection.exploit_type {
                ExploitType::RopChain => stats.rop_detections += 1,
                ExploitType::HeapSpray => stats.heap_spray_detections += 1,
                ExploitType::UseAfterFree => stats.uaf_detections += 1,
                _ => {}
            }
        }

        stats
    }

    /// Cleanup old allocations
    fn cleanup_old_allocations(&mut self, pid: u32) {
        if let Some(allocations) = self.heap_allocations.get_mut(&pid) {
            let cutoff_time = Self::current_timestamp() - 3600; // 1 hour
            allocations.retain(|a| a.timestamp > cutoff_time);
        }
    }

    /// Get current Unix timestamp
    fn current_timestamp() -> i64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64
    }
}

/// Exploit detection statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct ExploitStats {
    pub total_detections: usize,
    pub by_exploit_type: HashMap<String, usize>,
    pub by_severity: HashMap<String, usize>,
    pub critical_count: usize,
    pub rop_detections: usize,
    pub heap_spray_detections: usize,
    pub uaf_detections: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exploit_detector_creation() {
        let config = ExploitDetectorConfig::default();
        let detector = ExploitDetector::new(config);

        assert_eq!(detector.detections.len(), 0);
    }

    #[test]
    fn test_rop_gadget_detection() {
        let config = ExploitDetectorConfig::default();
        let mut detector = ExploitDetector::new(config);

        // Simulate memory with ROP gadgets (ret instructions)
        let memory_data = vec![
            0xC3, 0x90, 0xC3, 0x90, 0xC3, 0x90, 0xC3, 0x90, 0xC3, 0x90,
        ];

        detector.analyze_memory_for_rop(
            1234,
            "test_process".to_string(),
            &memory_data,
            0x400000,
        );

        assert!(detector.detections.len() > 0);
    }

    #[test]
    fn test_double_free_detection() {
        let config = ExploitDetectorConfig::default();
        let mut detector = ExploitDetector::new(config);

        let address = 0x1000;

        // First free
        detector.record_heap_free(1234, "test".to_string(), address);
        assert_eq!(detector.detections.len(), 0);

        // Second free (double free)
        detector.record_heap_free(1234, "test".to_string(), address);
        assert_eq!(detector.detections.len(), 1);
        assert!(matches!(detector.detections[0].exploit_type, ExploitType::DoubleFree));
    }
}
