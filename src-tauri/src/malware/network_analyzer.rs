/*!
 * Advanced Network Traffic Analyzer
 *
 * Detects malicious network activity and C2 communications:
 * - Command and Control (C2) beaconing patterns
 * - Suspicious DNS queries (DNS tunneling, DGA domains)
 * - Data exfiltration over network protocols
 * - Tor/VPN/Proxy usage detection
 * - Unusual port usage and protocol anomalies
 * - Known malicious IP/domain connections
 * - TLS/SSL certificate anomalies
 * - HTTP/HTTPS C2 channel detection
 *
 * Maps network behaviors to MITRE ATT&CK techniques for Command and Control
 * and Exfiltration tactics.
 */

use serde::{Serialize, Deserialize};
use std::collections::{HashMap, VecDeque};
use std::time::{SystemTime, UNIX_EPOCH};
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

/// Network threat detection result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkThreatDetection {
    pub source_process_id: u32,
    pub source_process: String,
    pub threat_type: NetworkThreatType,
    pub severity: String, // "critical", "high", "medium", "low"
    pub confidence: f32, // 0.0 - 1.0
    pub remote_ip: String,
    pub remote_port: u16,
    pub protocol: String,
    pub timestamp: i64,
    pub mitre_technique: Option<String>,
    pub indicators: Vec<String>,
    pub description: String,
    pub bytes_transferred: u64,
}

/// Types of network threats
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum NetworkThreatType {
    /// C2 beaconing (periodic callbacks)
    C2Beaconing,

    /// Connection to known malicious IP/domain
    MaliciousDestination,

    /// DNS tunneling detected
    DnsTunneling,

    /// Domain Generation Algorithm (DGA) domain
    DgaDomain,

    /// Data exfiltration over HTTP/HTTPS
    DataExfiltration,

    /// Tor network usage
    TorUsage,

    /// Suspicious VPN/Proxy usage
    SuspiciousProxy,

    /// Unusual port usage
    UnusualPort,

    /// Protocol anomaly
    ProtocolAnomaly,

    /// TLS/SSL certificate anomaly
    TlsAnomaly,

    /// HTTP C2 channel
    HttpC2Channel,

    /// DNS C2 channel
    DnsC2Channel,

    /// Fast flux network
    FastFlux,

    /// Port scanning activity
    PortScanning,
}

/// Network connection tracking
#[derive(Debug, Clone)]
struct ConnectionTracker {
    remote_ip: String,
    remote_port: u16,
    protocol: String,
    first_seen: i64,
    last_seen: i64,
    connection_count: usize,
    bytes_sent: u64,
    bytes_received: u64,
    intervals: VecDeque<i64>, // Time intervals between connections (for beaconing)
}

/// DNS query tracking
#[derive(Debug, Clone)]
struct DnsQueryTracker {
    domain: String,
    query_count: usize,
    first_seen: i64,
    last_seen: i64,
    unique_subdomains: Vec<String>,
    total_query_length: usize,
}

/// Network analyzer configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkAnalyzerConfig {
    /// Monitor for C2 beaconing patterns
    pub detect_c2_beaconing: bool,

    /// Monitor DNS queries
    pub monitor_dns: bool,

    /// Detect data exfiltration
    pub detect_exfiltration: bool,

    /// Monitor for Tor/VPN usage
    pub detect_anonymization: bool,

    /// Beaconing detection threshold (connections)
    pub beaconing_threshold: usize,

    /// Beaconing jitter tolerance (seconds)
    pub beaconing_jitter: i64,

    /// Data exfiltration threshold (bytes)
    pub exfiltration_threshold: u64,

    /// Whitelist of trusted IPs/domains
    pub trusted_destinations: Vec<String>,
}

impl Default for NetworkAnalyzerConfig {
    fn default() -> Self {
        Self {
            detect_c2_beaconing: true,
            monitor_dns: true,
            detect_exfiltration: true,
            detect_anonymization: true,
            beaconing_threshold: 5, // 5 connections with similar intervals
            beaconing_jitter: 10, // 10 seconds tolerance
            exfiltration_threshold: 100 * 1024 * 1024, // 100 MB
            trusted_destinations: vec![
                "google.com".to_string(),
                "github.com".to_string(),
                "cloudflare.com".to_string(),
            ],
        }
    }
}

/// Network traffic analyzer
pub struct NetworkAnalyzer {
    config: NetworkAnalyzerConfig,
    connections: HashMap<String, ConnectionTracker>, // Key: "pid:ip:port"
    dns_queries: HashMap<String, DnsQueryTracker>, // Key: "pid:domain"
    detections: Vec<NetworkThreatDetection>,
    known_malicious_ips: HashMap<String, String>, // IP -> Description
    known_malicious_domains: HashMap<String, String>, // Domain -> Description
    tor_exit_nodes: Vec<String>,
}

impl NetworkAnalyzer {
    /// Create new network analyzer
    pub fn new(config: NetworkAnalyzerConfig) -> Self {
        let mut analyzer = Self {
            config,
            connections: HashMap::new(),
            dns_queries: HashMap::new(),
            detections: Vec::new(),
            known_malicious_ips: HashMap::new(),
            known_malicious_domains: HashMap::new(),
            tor_exit_nodes: Vec::new(),
        };

        analyzer.load_threat_intelligence();

        log::info!("Network traffic analyzer initialized");

        analyzer
    }

    /// Start network monitoring
    pub fn start_monitoring(&mut self) -> Result<(), String> {
        log::info!("Starting network traffic monitoring");

        // TODO: Set up network monitoring:
        // - Linux: eBPF probes on network syscalls, netfilter hooks
        // - Windows: WFP (Windows Filtering Platform) callouts
        // - Cross-platform: pcap for packet capture

        Ok(())
    }

    /// Stop network monitoring
    pub fn stop_monitoring(&mut self) {
        log::info!("Stopping network traffic monitoring");
        // TODO: Clean up monitoring hooks
    }

    /// Record network connection
    pub fn record_connection(
        &mut self,
        pid: u32,
        process_name: String,
        remote_ip: String,
        remote_port: u16,
        protocol: String,
        bytes_sent: u64,
        bytes_received: u64,
    ) {
        // Check if destination is trusted
        if self.is_trusted_destination(&remote_ip) {
            return;
        }

        let timestamp = Self::current_timestamp();
        let key = format!("{}:{}:{}", pid, remote_ip, remote_port);

        // Get or create connection tracker
        let tracker = self.connections.entry(key.clone()).or_insert_with(|| {
            ConnectionTracker {
                remote_ip: remote_ip.clone(),
                remote_port,
                protocol: protocol.clone(),
                first_seen: timestamp,
                last_seen: timestamp,
                connection_count: 0,
                bytes_sent: 0,
                bytes_received: 0,
                intervals: VecDeque::new(),
            }
        });

        // Record interval (for beaconing detection)
        if tracker.connection_count > 0 {
            let interval = timestamp - tracker.last_seen;
            tracker.intervals.push_back(interval);

            // Keep only recent intervals
            if tracker.intervals.len() > 20 {
                tracker.intervals.pop_front();
            }
        }

        tracker.last_seen = timestamp;
        tracker.connection_count += 1;
        tracker.bytes_sent += bytes_sent;
        tracker.bytes_received += bytes_received;

        // Extract data before calling methods (to avoid borrow checker issues)
        let connection_count = tracker.connection_count;
        let total_bytes_sent = tracker.bytes_sent;
        let tracker_clone = tracker.clone();

        // Drop the mutable borrow
        drop(tracker);

        // Check for known malicious IP
        if self.known_malicious_ips.contains_key(&remote_ip) {
            self.detect_malicious_destination(pid, &process_name, &remote_ip, remote_port, &protocol);
        }

        // Detect C2 beaconing
        if self.config.detect_c2_beaconing && connection_count >= self.config.beaconing_threshold {
            self.detect_c2_beaconing(pid, &process_name, &key, &tracker_clone);
        }

        // Detect data exfiltration
        if self.config.detect_exfiltration && total_bytes_sent >= self.config.exfiltration_threshold {
            self.detect_data_exfiltration(pid, &process_name, &tracker_clone);
        }

        // Detect Tor usage
        if self.config.detect_anonymization && self.is_tor_exit_node(&remote_ip) {
            self.detect_tor_usage(pid, &process_name, &remote_ip, remote_port);
        }

        // Cleanup old connections
        self.cleanup_old_connections();
    }

    /// Record DNS query
    pub fn record_dns_query(
        &mut self,
        pid: u32,
        process_name: String,
        domain: String,
        query_type: String,
    ) {
        if !self.config.monitor_dns {
            return;
        }

        let timestamp = Self::current_timestamp();
        let key = format!("{}:{}", pid, domain);

        // Get or create DNS query tracker
        let tracker = self.dns_queries.entry(key.clone()).or_insert_with(|| {
            DnsQueryTracker {
                domain: domain.clone(),
                query_count: 0,
                first_seen: timestamp,
                last_seen: timestamp,
                unique_subdomains: Vec::new(),
                total_query_length: 0,
            }
        });

        tracker.query_count += 1;
        tracker.last_seen = timestamp;
        tracker.total_query_length += domain.len();

        // Track unique subdomains
        if !tracker.unique_subdomains.contains(&domain) {
            tracker.unique_subdomains.push(domain.clone());
        }

        // Extract data before calling methods (to avoid borrow checker issues)
        let query_count = tracker.query_count;
        let tracker_clone = tracker.clone();

        // Drop the mutable borrow
        drop(tracker);

        // Check for known malicious domain
        if self.is_malicious_domain(&domain) {
            self.detect_malicious_domain(pid, &process_name, &domain);
        }

        // Detect DNS tunneling
        if self.is_dns_tunneling(&domain, query_count) {
            self.detect_dns_tunneling(pid, &process_name, &domain, &tracker_clone);
        }

        // Detect DGA domains
        if self.is_dga_domain(&domain) {
            self.detect_dga_domain(pid, &process_name, &domain);
        }

        // Cleanup old DNS queries
        self.cleanup_old_dns_queries();
    }

    /// Detect C2 beaconing pattern
    fn detect_c2_beaconing(
        &mut self,
        pid: u32,
        process_name: &str,
        connection_key: &str,
        tracker: &ConnectionTracker,
    ) {
        // Check if intervals are regular (indicating beaconing)
        if tracker.intervals.len() < self.config.beaconing_threshold {
            return;
        }

        // Calculate average interval
        let avg_interval: i64 = tracker.intervals.iter().sum::<i64>() / tracker.intervals.len() as i64;

        // Check if all intervals are within jitter tolerance
        let is_regular = tracker.intervals.iter().all(|&interval| {
            (interval - avg_interval).abs() <= self.config.beaconing_jitter
        });

        if is_regular {
            log::warn!(
                "⚠️  C2 beaconing detected: {} (PID {}) -> {}:{} (avg interval: {}s)",
                process_name,
                pid,
                tracker.remote_ip,
                tracker.remote_port,
                avg_interval
            );

            self.create_detection(
                pid,
                process_name.to_string(),
                NetworkThreatType::C2Beaconing,
                90.0, // High severity
                0.88,
                tracker.remote_ip.clone(),
                tracker.remote_port,
                tracker.protocol.clone(),
                "T1071", // Application Layer Protocol
                vec![
                    format!("Regular beaconing pattern detected (interval: {}s)", avg_interval),
                    format!("{} connections observed", tracker.connection_count),
                    format!("Jitter: ±{} seconds", self.config.beaconing_jitter),
                ],
                format!("C2 beaconing to {}:{} every ~{} seconds", tracker.remote_ip, tracker.remote_port, avg_interval),
                tracker.bytes_sent + tracker.bytes_received,
            );
        }
    }

    /// Detect connection to malicious destination
    fn detect_malicious_destination(
        &mut self,
        pid: u32,
        process_name: &str,
        remote_ip: &str,
        remote_port: u16,
        protocol: &str,
    ) {
        let threat_desc = self.known_malicious_ips.get(remote_ip)
            .cloned()
            .unwrap_or_else(|| "Known threat".to_string());

        log::warn!(
            "⚠️  Malicious destination detected: {} (PID {}) -> {} ({})",
            process_name,
            pid,
            remote_ip,
            threat_desc
        );

        self.create_detection(
            pid,
            process_name.to_string(),
            NetworkThreatType::MaliciousDestination,
            95.0,
            0.95,
            remote_ip.to_string(),
            remote_port,
            protocol.to_string(),
            "T1071", // Application Layer Protocol
            vec![
                format!("Known malicious IP: {}", remote_ip),
                format!("Threat: {}", threat_desc),
            ],
            format!("Connection to known malicious IP: {} ({})", remote_ip, threat_desc),
            0,
        );
    }

    /// Detect DNS tunneling
    fn detect_dns_tunneling(
        &mut self,
        pid: u32,
        process_name: &str,
        domain: &str,
        tracker: &DnsQueryTracker,
    ) {
        log::warn!(
            "⚠️  DNS tunneling detected: {} (PID {}) querying {} ({} queries)",
            process_name,
            pid,
            domain,
            tracker.query_count
        );

        self.create_detection(
            pid,
            process_name.to_string(),
            NetworkThreatType::DnsTunneling,
            85.0,
            0.82,
            "0.0.0.0".to_string(), // DNS server
            53,
            "DNS".to_string(),
            "T1071.004", // DNS Application Layer Protocol
            vec![
                format!("Suspicious DNS query pattern: {}", domain),
                format!("Query count: {}", tracker.query_count),
                format!("Average query length: {}", tracker.total_query_length / tracker.query_count),
            ],
            format!("DNS tunneling via domain: {}", domain),
            0,
        );
    }

    /// Detect DGA domain
    fn detect_dga_domain(
        &mut self,
        pid: u32,
        process_name: &str,
        domain: &str,
    ) {
        log::warn!(
            "⚠️  DGA domain detected: {} (PID {}) querying {}",
            process_name,
            pid,
            domain
        );

        self.create_detection(
            pid,
            process_name.to_string(),
            NetworkThreatType::DgaDomain,
            80.0,
            0.75,
            "0.0.0.0".to_string(),
            53,
            "DNS".to_string(),
            "T1568.002", // Domain Generation Algorithms
            vec![
                format!("DGA-generated domain: {}", domain),
                "High entropy domain name".to_string(),
            ],
            format!("DGA domain query: {}", domain),
            0,
        );
    }

    /// Detect malicious domain
    fn detect_malicious_domain(
        &mut self,
        pid: u32,
        process_name: &str,
        domain: &str,
    ) {
        let threat_desc = self.known_malicious_domains.get(domain)
            .cloned()
            .unwrap_or_else(|| "Known malicious domain".to_string());

        log::warn!(
            "⚠️  Malicious domain detected: {} (PID {}) querying {} ({})",
            process_name,
            pid,
            domain,
            threat_desc
        );

        self.create_detection(
            pid,
            process_name.to_string(),
            NetworkThreatType::MaliciousDestination,
            92.0,
            0.92,
            "0.0.0.0".to_string(),
            53,
            "DNS".to_string(),
            "T1071", // Application Layer Protocol
            vec![
                format!("Known malicious domain: {}", domain),
                format!("Threat: {}", threat_desc),
            ],
            format!("DNS query to malicious domain: {} ({})", domain, threat_desc),
            0,
        );
    }

    /// Detect data exfiltration
    fn detect_data_exfiltration(
        &mut self,
        pid: u32,
        process_name: &str,
        tracker: &ConnectionTracker,
    ) {
        log::warn!(
            "⚠️  Data exfiltration detected: {} (PID {}) sent {} bytes to {}:{}",
            process_name,
            pid,
            tracker.bytes_sent,
            tracker.remote_ip,
            tracker.remote_port
        );

        self.create_detection(
            pid,
            process_name.to_string(),
            NetworkThreatType::DataExfiltration,
            88.0,
            0.80,
            tracker.remote_ip.clone(),
            tracker.remote_port,
            tracker.protocol.clone(),
            "T1041", // Exfiltration Over C2 Channel
            vec![
                format!("Large data transfer: {} MB", tracker.bytes_sent / (1024 * 1024)),
                format!("Destination: {}:{}", tracker.remote_ip, tracker.remote_port),
            ],
            format!("Data exfiltration to {}:{} ({} MB)", tracker.remote_ip, tracker.remote_port, tracker.bytes_sent / (1024 * 1024)),
            tracker.bytes_sent,
        );
    }

    /// Detect Tor usage
    fn detect_tor_usage(
        &mut self,
        pid: u32,
        process_name: &str,
        remote_ip: &str,
        remote_port: u16,
    ) {
        log::warn!(
            "⚠️  Tor usage detected: {} (PID {}) connecting to Tor exit node {}",
            process_name,
            pid,
            remote_ip
        );

        self.create_detection(
            pid,
            process_name.to_string(),
            NetworkThreatType::TorUsage,
            70.0,
            0.85,
            remote_ip.to_string(),
            remote_port,
            "TCP".to_string(),
            "T1090.003", // Multi-hop Proxy
            vec![
                format!("Tor exit node: {}", remote_ip),
                "Anonymization network detected".to_string(),
            ],
            format!("Connection to Tor exit node: {}", remote_ip),
            0,
        );
    }

    /// Check if DNS query indicates tunneling
    fn is_dns_tunneling(&self, domain: &str, query_count: usize) -> bool {
        // DNS tunneling indicators:
        // 1. Excessive query count
        // 2. Long subdomain names
        // 3. High entropy subdomains

        if query_count > 50 {
            return true;
        }

        // Check subdomain length
        if let Some(subdomain) = domain.split('.').next() {
            if subdomain.len() > 50 {
                return true;
            }
        }

        false
    }

    /// Check if domain is DGA-generated
    fn is_dga_domain(&self, domain: &str) -> bool {
        // DGA domain indicators:
        // 1. High entropy (random-looking)
        // 2. Unusual character patterns
        // 3. No recognizable words

        let subdomain = domain.split('.').next().unwrap_or(domain);

        // Check for high consonant-to-vowel ratio
        let consonants = subdomain.chars().filter(|c| {
            matches!(c.to_ascii_lowercase(), 'b' | 'c' | 'd' | 'f' | 'g' | 'h' | 'j' | 'k' | 'l' | 'm' | 'n' | 'p' | 'q' | 'r' | 's' | 't' | 'v' | 'w' | 'x' | 'y' | 'z')
        }).count();

        let vowels = subdomain.chars().filter(|c| {
            matches!(c.to_ascii_lowercase(), 'a' | 'e' | 'i' | 'o' | 'u')
        }).count();

        // High consonant ratio indicates DGA
        if vowels > 0 && consonants / vowels > 4 {
            return true;
        }

        // Check for unusual length
        if subdomain.len() > 20 && subdomain.len() < 30 {
            return true;
        }

        false
    }

    /// Check if domain is known malicious
    fn is_malicious_domain(&self, domain: &str) -> bool {
        self.known_malicious_domains.contains_key(domain)
    }

    /// Check if IP is Tor exit node
    fn is_tor_exit_node(&self, ip: &str) -> bool {
        self.tor_exit_nodes.contains(&ip.to_string())
    }

    /// Check if destination is trusted
    fn is_trusted_destination(&self, destination: &str) -> bool {
        self.config.trusted_destinations.iter().any(|t| destination.contains(t))
    }

    /// Create network threat detection
    fn create_detection(
        &mut self,
        pid: u32,
        process_name: String,
        threat_type: NetworkThreatType,
        severity_score: f32,
        confidence: f32,
        remote_ip: String,
        remote_port: u16,
        protocol: String,
        mitre_technique: &str,
        indicators: Vec<String>,
        description: String,
        bytes_transferred: u64,
    ) {
        let severity = if severity_score >= 90.0 {
            "critical"
        } else if severity_score >= 70.0 {
            "high"
        } else if severity_score >= 50.0 {
            "medium"
        } else {
            "low"
        };

        let detection = NetworkThreatDetection {
            source_process_id: pid,
            source_process: process_name,
            threat_type,
            severity: severity.to_string(),
            confidence,
            remote_ip,
            remote_port,
            protocol,
            timestamp: Self::current_timestamp(),
            mitre_technique: Some(mitre_technique.to_string()),
            indicators,
            description,
            bytes_transferred,
        };

        self.detections.push(detection);
    }

    /// Load threat intelligence
    fn load_threat_intelligence(&mut self) {
        // Known malicious IPs (examples - in production, load from threat feeds)
        self.known_malicious_ips.insert("198.51.100.1".to_string(), "C2 server".to_string());
        self.known_malicious_ips.insert("203.0.113.1".to_string(), "Malware infrastructure".to_string());

        // Known malicious domains
        self.known_malicious_domains.insert("evil.com".to_string(), "Known malware domain".to_string());
        self.known_malicious_domains.insert("malicious-c2.net".to_string(), "C2 domain".to_string());

        // Tor exit nodes (sample - in production, load from public lists)
        self.tor_exit_nodes.push("1.2.3.4".to_string());

        log::debug!(
            "Loaded threat intelligence: {} IPs, {} domains, {} Tor nodes",
            self.known_malicious_ips.len(),
            self.known_malicious_domains.len(),
            self.tor_exit_nodes.len()
        );
    }

    /// Get all detections
    pub fn get_detections(&self) -> &[NetworkThreatDetection] {
        &self.detections
    }

    /// Get recent detections
    pub fn get_recent_detections(&self, count: usize) -> Vec<NetworkThreatDetection> {
        self.detections.iter()
            .rev()
            .take(count)
            .cloned()
            .collect()
    }

    /// Get detections by threat type
    pub fn get_detections_by_type(&self, threat_type: &NetworkThreatType) -> Vec<NetworkThreatDetection> {
        self.detections.iter()
            .filter(|d| &d.threat_type == threat_type)
            .cloned()
            .collect()
    }

    /// Clear old detections
    pub fn clear_old_detections(&mut self, older_than_seconds: i64) {
        let cutoff_time = Self::current_timestamp() - older_than_seconds;
        self.detections.retain(|d| d.timestamp > cutoff_time);
    }

    /// Get network statistics
    pub fn get_stats(&self) -> NetworkAnalyzerStats {
        let mut stats = NetworkAnalyzerStats {
            total_detections: self.detections.len(),
            by_threat_type: HashMap::new(),
            by_severity: HashMap::new(),
            total_connections: self.connections.len(),
            total_dns_queries: self.dns_queries.len(),
            critical_count: 0,
        };

        for detection in &self.detections {
            *stats.by_threat_type.entry(format!("{:?}", detection.threat_type)).or_insert(0) += 1;
            *stats.by_severity.entry(detection.severity.clone()).or_insert(0) += 1;

            if detection.severity == "critical" {
                stats.critical_count += 1;
            }
        }

        stats
    }

    /// Cleanup old connections
    fn cleanup_old_connections(&mut self) {
        let cutoff_time = Self::current_timestamp() - 3600; // 1 hour
        self.connections.retain(|_, tracker| tracker.last_seen > cutoff_time);
    }

    /// Cleanup old DNS queries
    fn cleanup_old_dns_queries(&mut self) {
        let cutoff_time = Self::current_timestamp() - 3600; // 1 hour
        self.dns_queries.retain(|_, tracker| tracker.last_seen > cutoff_time);
    }

    /// Get current Unix timestamp
    fn current_timestamp() -> i64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64
    }
}

/// Network analyzer statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkAnalyzerStats {
    pub total_detections: usize,
    pub by_threat_type: HashMap<String, usize>,
    pub by_severity: HashMap<String, usize>,
    pub total_connections: usize,
    pub total_dns_queries: usize,
    pub critical_count: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_network_analyzer_creation() {
        let config = NetworkAnalyzerConfig::default();
        let analyzer = NetworkAnalyzer::new(config);

        assert_eq!(analyzer.detections.len(), 0);
        assert!(analyzer.known_malicious_ips.len() > 0);
    }

    #[test]
    fn test_dga_domain_detection() {
        let config = NetworkAnalyzerConfig::default();
        let analyzer = NetworkAnalyzer::new(config);

        // DGA-like domain (high consonant ratio)
        assert!(analyzer.is_dga_domain("xqzplkmnbvcxwert.com"));

        // Normal domain
        assert!(!analyzer.is_dga_domain("google.com"));
    }

    #[test]
    fn test_trusted_destination() {
        let config = NetworkAnalyzerConfig::default();
        let analyzer = NetworkAnalyzer::new(config);

        assert!(analyzer.is_trusted_destination("google.com"));
        assert!(!analyzer.is_trusted_destination("evil.com"));
    }
}
