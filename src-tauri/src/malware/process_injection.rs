/*!
 * Process Injection Detector
 *
 * Detects advanced process injection techniques used by malware:
 * - CreateRemoteThread injection
 * - DLL injection (LoadLibrary)
 * - Reflective DLL injection
 * - Process hollowing
 * - Process doppelg�nging
 * - AtomBombing
 * - Thread execution hijacking
 * - APC injection
 * - PTRACE injection (Linux)
 *
 * Maps to MITRE ATT&CK T1055 (Process Injection) and sub-techniques
 */

use serde::{Serialize, Deserialize};
use std::collections::HashMap;

/// Injection detection result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InjectionDetection {
    pub source_pid: u32,
    pub source_process: String,
    pub target_pid: u32,
    pub target_process: String,
    pub technique: InjectionTechnique,
    pub severity: String,
    pub confidence: f32, // 0.0 - 1.0
    pub timestamp: i64,
    pub mitre_technique: String,
    pub indicators: Vec<String>,
}

/// Process injection techniques
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum InjectionTechnique {
    /// Classic CreateRemoteThread + WriteProcessMemory
    CreateRemoteThread,

    /// DLL injection via LoadLibrary
    DllInjection,

    /// Reflective DLL injection (no disk file)
    ReflectiveDllInjection,

    /// Process hollowing (map over legitimate process)
    ProcessHollowing,

    /// Process doppelgänging (TxF abuse)
    ProcessDoppelganging,

    /// AtomBombing technique
    AtomBombing,

    /// Thread execution hijacking
    ThreadHijacking,

    /// Asynchronous Procedure Call injection
    ApcInjection,

    /// PTRACE-based injection (Linux)
    PtraceInjection,

    /// SetWindowsHookEx injection
    HookInjection,

    /// Extra window memory injection
    ExtraWindowMemoryInjection,
}

/// Injection detector configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InjectionDetectorConfig {
    /// Monitor CreateRemoteThread calls
    pub monitor_remote_threads: bool,

    /// Monitor DLL loading
    pub monitor_dll_loading: bool,

    /// Monitor memory writes to other processes
    pub monitor_memory_writes: bool,

    /// Monitor process creation
    pub monitor_process_creation: bool,

    /// Whitelist of trusted processes (won't trigger alerts)
    pub trusted_processes: Vec<String>,
}

impl Default for InjectionDetectorConfig {
    fn default() -> Self {
        Self {
            monitor_remote_threads: true,
            monitor_dll_loading: true,
            monitor_memory_writes: true,
            monitor_process_creation: true,
            trusted_processes: vec![
                "systemd".to_string(),
                "init".to_string(),
                "kernel".to_string(),
                "debugger".to_string(),
            ],
        }
    }
}

/// Process injection detector
pub struct ProcessInjectionDetector {
    config: InjectionDetectorConfig,
    detections: Vec<InjectionDetection>,
    monitored_processes: HashMap<u32, ProcessInfo>,
}

/// Process information for monitoring
#[derive(Debug, Clone)]
struct ProcessInfo {
    pid: u32,
    name: String,
    parent_pid: u32,
    cmd_line: String,
    start_time: i64,
}

impl ProcessInjectionDetector {
    /// Create new injection detector
    pub fn new(config: InjectionDetectorConfig) -> Self {
        Self {
            config,
            detections: Vec::new(),
            monitored_processes: HashMap::new(),
        }
    }

    /// Start monitoring for injection attempts
    pub fn start_monitoring(&mut self) -> Result<(), String> {
        log::info!("Starting process injection detector");

        // Initialize process list
        self.refresh_process_list();

        // TODO: Set up kernel-level monitoring:
        // - Linux: eBPF probes on ptrace, process_vm_writev
        // - Windows: ETW tracing for process/thread events

        log::info!("Process injection monitoring active");

        Ok(())
    }

    /// Stop monitoring
    pub fn stop_monitoring(&mut self) {
        log::info!("Stopping process injection detector");
        // TODO: Clean up monitoring hooks
    }

    /// Detect CreateRemoteThread injection
    pub fn detect_remote_thread(
        &mut self,
        source_pid: u32,
        target_pid: u32,
    ) -> Option<InjectionDetection> {
        if !self.config.monitor_remote_threads {
            return None;
        }

        // Get process names
        let source_process = self.get_process_name(source_pid)?;
        let target_process = self.get_process_name(target_pid)?;

        // Check if source is trusted
        if self.is_trusted_process(&source_process) {
            return None;
        }

        log::warn!(
            "⚠️  Remote thread creation detected: {} (PID {}) -> {} (PID {})",
            source_process,
            source_pid,
            target_process,
            target_pid
        );

        Some(InjectionDetection {
            source_pid,
            source_process,
            target_pid,
            target_process,
            technique: InjectionTechnique::CreateRemoteThread,
            severity: "high".to_string(),
            confidence: 0.85,
            timestamp: chrono::Utc::now().timestamp(),
            mitre_technique: "T1055.002".to_string(),
            indicators: vec![
                "CreateRemoteThread API call".to_string(),
                "Cross-process thread creation".to_string(),
            ],
        })
    }

    /// Detect DLL injection
    pub fn detect_dll_injection(
        &mut self,
        source_pid: u32,
        target_pid: u32,
        dll_path: &str,
    ) -> Option<InjectionDetection> {
        if !self.config.monitor_dll_loading {
            return None;
        }

        let source_process = self.get_process_name(source_pid)?;
        let target_process = self.get_process_name(target_pid)?;

        if self.is_trusted_process(&source_process) {
            return None;
        }

        log::warn!(
            "⚠️  DLL injection detected: {} injecting {} into {} (PID {})",
            source_process,
            dll_path,
            target_process,
            target_pid
        );

        Some(InjectionDetection {
            source_pid,
            source_process,
            target_pid,
            target_process,
            technique: InjectionTechnique::DllInjection,
            severity: "high".to_string(),
            confidence: 0.90,
            timestamp: chrono::Utc::now().timestamp(),
            mitre_technique: "T1055.001".to_string(),
            indicators: vec![
                format!("DLL injected: {}", dll_path),
                "LoadLibrary-based injection".to_string(),
            ],
        })
    }

    /// Detect process hollowing
    pub fn detect_process_hollowing(
        &mut self,
        source_pid: u32,
        target_pid: u32,
    ) -> Option<InjectionDetection> {
        let source_process = self.get_process_name(source_pid)?;
        let target_process = self.get_process_name(target_pid)?;

        log::warn!(
            "⚠️  Process hollowing detected: {} hollowing {} (PID {})",
            source_process,
            target_process,
            target_pid
        );

        Some(InjectionDetection {
            source_pid,
            source_process,
            target_pid,
            target_process,
            technique: InjectionTechnique::ProcessHollowing,
            severity: "critical".to_string(),
            confidence: 0.95,
            timestamp: chrono::Utc::now().timestamp(),
            mitre_technique: "T1055.012".to_string(),
            indicators: vec![
                "Process memory unmapped".to_string(),
                "Malicious code mapped over legitimate process".to_string(),
            ],
        })
    }

    /// Detect PTRACE injection (Linux)
    #[cfg(target_os = "linux")]
    pub fn detect_ptrace_injection(
        &mut self,
        source_pid: u32,
        target_pid: u32,
    ) -> Option<InjectionDetection> {
        let source_process = self.get_process_name(source_pid)?;
        let target_process = self.get_process_name(target_pid)?;

        // Check if this is legitimate debugging
        if self.is_trusted_process(&source_process) {
            return None;
        }

        log::warn!(
            "⚠️  PTRACE injection detected: {} (PID {}) attaching to {} (PID {})",
            source_process,
            source_pid,
            target_process,
            target_pid
        );

        Some(InjectionDetection {
            source_pid,
            source_process,
            target_pid,
            target_process,
            technique: InjectionTechnique::PtraceInjection,
            severity: "high".to_string(),
            confidence: 0.80,
            timestamp: chrono::Utc::now().timestamp(),
            mitre_technique: "T1055.008".to_string(),
            indicators: vec![
                "PTRACE_ATTACH syscall".to_string(),
                "Process memory manipulation via ptrace".to_string(),
            ],
        })
    }

    /// Detect APC injection
    pub fn detect_apc_injection(
        &mut self,
        source_pid: u32,
        target_pid: u32,
    ) -> Option<InjectionDetection> {
        let source_process = self.get_process_name(source_pid)?;
        let target_process = self.get_process_name(target_pid)?;

        log::warn!(
            "⚠️  APC injection detected: {} (PID {}) -> {} (PID {})",
            source_process,
            source_pid,
            target_process,
            target_pid
        );

        Some(InjectionDetection {
            source_pid,
            source_process,
            target_pid,
            target_process,
            technique: InjectionTechnique::ApcInjection,
            severity: "high".to_string(),
            confidence: 0.85,
            timestamp: chrono::Utc::now().timestamp(),
            mitre_technique: "T1055.004".to_string(),
            indicators: vec![
                "QueueUserAPC API call".to_string(),
                "Asynchronous procedure call injection".to_string(),
            ],
        })
    }

    /// Get all detections
    pub fn get_detections(&self) -> &[InjectionDetection] {
        &self.detections
    }

    /// Get recent detections (last N)
    pub fn get_recent_detections(&self, count: usize) -> Vec<InjectionDetection> {
        self.detections
            .iter()
            .rev()
            .take(count)
            .cloned()
            .collect()
    }

    /// Clear old detections
    pub fn clear_old_detections(&mut self, older_than_seconds: i64) {
        let cutoff_time = chrono::Utc::now().timestamp() - older_than_seconds;
        self.detections.retain(|d| d.timestamp > cutoff_time);
    }

    /// Get detection statistics
    pub fn get_stats(&self) -> InjectionStats {
        let mut stats = InjectionStats {
            total_detections: self.detections.len(),
            by_technique: HashMap::new(),
            by_severity: HashMap::new(),
            high_confidence_count: 0,
        };

        for detection in &self.detections {
            // Count by technique
            let technique_name = format!("{:?}", detection.technique);
            *stats.by_technique.entry(technique_name).or_insert(0) += 1;

            // Count by severity
            *stats.by_severity.entry(detection.severity.clone()).or_insert(0) += 1;

            // High confidence count
            if detection.confidence > 0.90 {
                stats.high_confidence_count += 1;
            }
        }

        stats
    }

    /// Refresh process list
    fn refresh_process_list(&mut self) {
        // TODO: Enumerate all running processes
        // Linux: Read /proc
        // Windows: Use EnumProcesses API
    }

    /// Get process name
    fn get_process_name(&self, pid: u32) -> Option<String> {
        // Check cache first
        if let Some(info) = self.monitored_processes.get(&pid) {
            return Some(info.name.clone());
        }

        // Read from system
        #[cfg(target_os = "linux")]
        {
            std::fs::read_to_string(format!("/proc/{}/comm", pid))
                .ok()
                .map(|s| s.trim().to_string())
        }

        #[cfg(not(target_os = "linux"))]
        {
            Some(format!("process_{}", pid))
        }
    }

    /// Check if process is trusted
    fn is_trusted_process(&self, process_name: &str) -> bool {
        self.config.trusted_processes.contains(&process_name.to_string())
    }
}

/// Injection detection statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct InjectionStats {
    pub total_detections: usize,
    pub by_technique: HashMap<String, usize>,
    pub by_severity: HashMap<String, usize>,
    pub high_confidence_count: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_injection_detector_creation() {
        let config = InjectionDetectorConfig::default();
        let detector = ProcessInjectionDetector::new(config);

        assert_eq!(detector.detections.len(), 0);
    }

    #[test]
    fn test_trusted_process_check() {
        let config = InjectionDetectorConfig::default();
        let detector = ProcessInjectionDetector::new(config);

        assert!(detector.is_trusted_process("systemd"));
        assert!(!detector.is_trusted_process("malware.exe"));
    }
}
