/*!
 * Advanced Behavioral Heuristics Engine
 *
 * Detects malicious behavior patterns through real-time analysis:
 * - Suspicious process behavior sequences
 * - API call pattern analysis
 * - Anomalous file operations
 * - Registry manipulation (Windows)
 * - Privilege escalation attempts
 * - Network behavior anomalies
 * - Credential access patterns
 * - Data exfiltration indicators
 *
 * Uses weighted scoring and MITRE ATT&CK correlation to identify threats
 * that signature-based detection misses.
 */

use serde::{Serialize, Deserialize};
use std::collections::{HashMap, VecDeque};
use std::time::{SystemTime, UNIX_EPOCH};

/// Behavioral detection result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehavioralDetection {
    pub process_id: u32,
    pub process_name: String,
    pub behavior_type: BehaviorType,
    pub severity: String, // "critical", "high", "medium", "low"
    pub confidence: f32, // 0.0 - 1.0
    pub risk_score: f32, // 0 - 100
    pub timestamp: i64,
    pub mitre_technique: Option<String>,
    pub indicators: Vec<BehaviorIndicator>,
    pub description: String,
}

/// Types of malicious behaviors
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum BehaviorType {
    /// Process creates multiple child processes rapidly
    ProcessBombing,

    /// Process creates scheduled tasks/cron jobs
    PersistenceMechanism,

    /// Attempts to access sensitive files (SAM, shadow, etc.)
    CredentialAccess,

    /// Modifies security settings or disables protections
    DefenseEvasion,

    /// Deletes or encrypts many files rapidly
    RansomwareBehavior,

    /// Suspicious network connections to known bad IPs
    CommandAndControl,

    /// Exfiltrates large amounts of data
    DataExfiltration,

    /// Attempts privilege escalation
    PrivilegeEscalation,

    /// Modifies system binaries or critical files
    SystemTampering,

    /// Injects code into other processes
    CodeInjection,

    /// Establishes persistence via autostart mechanisms
    BootPersistence,

    /// Lateral movement indicators
    LateralMovement,

    /// Discovery/reconnaissance behavior
    Discovery,

    /// Resource hijacking (crypto mining, etc.)
    ResourceHijacking,
}

/// Individual behavior indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehaviorIndicator {
    pub indicator_type: String,
    pub value: String,
    pub weight: f32, // Contribution to overall risk score
    pub timestamp: i64,
}

/// Behavioral engine configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehavioralConfig {
    /// Enable process behavior monitoring
    pub monitor_process_behavior: bool,

    /// Enable file operation monitoring
    pub monitor_file_operations: bool,

    /// Enable network behavior monitoring
    pub monitor_network_behavior: bool,

    /// Enable registry monitoring (Windows)
    pub monitor_registry: bool,

    /// Minimum risk score to trigger alert (0-100)
    pub alert_threshold: f32,

    /// Time window for behavior analysis (seconds)
    pub analysis_window: u64,

    /// Maximum events to track per process
    pub max_events_per_process: usize,

    /// Whitelist of trusted processes
    pub trusted_processes: Vec<String>,
}

impl Default for BehavioralConfig {
    fn default() -> Self {
        Self {
            monitor_process_behavior: true,
            monitor_file_operations: true,
            monitor_network_behavior: true,
            monitor_registry: true,
            alert_threshold: 70.0,
            analysis_window: 300, // 5 minutes
            max_events_per_process: 1000,
            trusted_processes: vec![
                "systemd".to_string(),
                "init".to_string(),
                "kernel".to_string(),
                "sshd".to_string(),
                "cron".to_string(),
            ],
        }
    }
}

/// Process behavior tracking
#[derive(Debug, Clone)]
struct ProcessBehavior {
    pid: u32,
    name: String,
    events: VecDeque<BehaviorEvent>,
    risk_score: f32,
    first_seen: i64,
    last_activity: i64,
}

/// Individual behavior event
#[derive(Debug, Clone)]
struct BehaviorEvent {
    event_type: BehaviorEventType,
    timestamp: i64,
    details: String,
    weight: f32,
}

#[derive(Debug, Clone, PartialEq)]
enum BehaviorEventType {
    ProcessCreation,
    FileWrite,
    FileDelete,
    FileEncryption,
    NetworkConnection,
    RegistryModification,
    PrivilegeRequest,
    SensitiveFileAccess,
    SystemFileModification,
    PersistenceCreation,
}

/// Behavioral heuristics engine
pub struct BehavioralEngine {
    config: BehavioralConfig,
    processes: HashMap<u32, ProcessBehavior>,
    detections: Vec<BehavioralDetection>,
    known_bad_ips: HashMap<String, String>, // IP -> Threat description
    sensitive_paths: Vec<String>,
}

impl BehavioralEngine {
    /// Create new behavioral engine
    pub fn new(config: BehavioralConfig) -> Self {
        let mut engine = Self {
            config,
            processes: HashMap::new(),
            detections: Vec::new(),
            known_bad_ips: HashMap::new(),
            sensitive_paths: Vec::new(),
        };

        engine.load_sensitive_paths();
        engine.load_threat_intelligence();

        log::info!("Behavioral heuristics engine initialized");

        engine
    }

    /// Start behavioral monitoring
    pub fn start_monitoring(&mut self) -> Result<(), String> {
        log::info!("Starting behavioral monitoring");

        // TODO: Set up event monitoring hooks:
        // - Linux: eBPF probes, auditd integration
        // - Windows: ETW (Event Tracing for Windows)
        // - macOS: Endpoint Security Framework

        Ok(())
    }

    /// Stop behavioral monitoring
    pub fn stop_monitoring(&mut self) {
        log::info!("Stopping behavioral monitoring");
        // TODO: Clean up monitoring hooks
    }

    /// Record process creation event
    pub fn record_process_creation(
        &mut self,
        pid: u32,
        process_name: String,
        parent_pid: u32,
        cmd_line: String,
    ) {
        if self.is_trusted_process(&process_name) {
            return;
        }

        let timestamp = Self::current_timestamp();

        // Get or create process behavior tracking
        let behavior = self.processes.entry(pid).or_insert_with(|| ProcessBehavior {
            pid,
            name: process_name.clone(),
            events: VecDeque::new(),
            risk_score: 0.0,
            first_seen: timestamp,
            last_activity: timestamp,
        });

        behavior.events.push_back(BehaviorEvent {
            event_type: BehaviorEventType::ProcessCreation,
            timestamp,
            details: format!("Parent PID: {}, CMD: {}", parent_pid, cmd_line),
            weight: 5.0,
        });

        behavior.last_activity = timestamp;

        // Detect process bombing
        self.detect_process_bombing(pid);

        // Cleanup old events
        self.cleanup_old_events(pid);
    }

    /// Record file operation
    pub fn record_file_operation(
        &mut self,
        pid: u32,
        operation: &str,
        file_path: &str,
    ) {
        if !self.config.monitor_file_operations {
            return;
        }

        let timestamp = Self::current_timestamp();

        // Check if accessing sensitive files (before mutable borrow)
        let is_sensitive = self.is_sensitive_path(file_path);

        if let Some(behavior) = self.processes.get_mut(&pid) {
            let (event_type, weight) = match operation {
                "write" => (BehaviorEventType::FileWrite, 3.0),
                "delete" => (BehaviorEventType::FileDelete, 10.0),
                "encrypt" => (BehaviorEventType::FileEncryption, 25.0),
                _ => return,
            };

            let weight = if is_sensitive { weight * 3.0 } else { weight };

            behavior.events.push_back(BehaviorEvent {
                event_type: event_type.clone(),
                timestamp,
                details: file_path.to_string(),
                weight,
            });

            behavior.last_activity = timestamp;

            // Drop the mutable borrow
            drop(behavior);

            // Detect ransomware behavior
            if event_type == BehaviorEventType::FileEncryption {
                self.detect_ransomware_behavior(pid);
            }

            // Detect credential access
            if is_sensitive {
                self.detect_credential_access(pid, file_path);
            }

            self.cleanup_old_events(pid);
        }
    }

    /// Record network connection
    pub fn record_network_connection(
        &mut self,
        pid: u32,
        remote_ip: &str,
        remote_port: u16,
        protocol: &str,
    ) {
        if !self.config.monitor_network_behavior {
            return;
        }

        let timestamp = Self::current_timestamp();

        if let Some(behavior) = self.processes.get_mut(&pid) {
            // Check if IP is known malicious
            let is_malicious_ip = self.known_bad_ips.contains_key(remote_ip);
            let weight = if is_malicious_ip { 50.0 } else { 5.0 };

            behavior.events.push_back(BehaviorEvent {
                event_type: BehaviorEventType::NetworkConnection,
                timestamp,
                details: format!("{}:{} ({})", remote_ip, remote_port, protocol),
                weight,
            });

            behavior.last_activity = timestamp;

            // Detect C2 communication
            if is_malicious_ip {
                self.detect_c2_communication(pid, remote_ip);
            }

            self.cleanup_old_events(pid);
        }
    }

    /// Record registry modification (Windows)
    #[cfg(target_os = "windows")]
    pub fn record_registry_modification(
        &mut self,
        pid: u32,
        key_path: &str,
        value_name: &str,
    ) {
        if !self.config.monitor_registry {
            return;
        }

        let timestamp = Self::current_timestamp();

        if let Some(behavior) = self.processes.get_mut(&pid) {
            // Check if modifying autostart keys (persistence)
            let is_autostart = key_path.contains("Run") || key_path.contains("RunOnce");
            let weight = if is_autostart { 30.0 } else { 10.0 };

            behavior.events.push_back(BehaviorEvent {
                event_type: BehaviorEventType::RegistryModification,
                timestamp,
                details: format!("{}\\{}", key_path, value_name),
                weight,
            });

            behavior.last_activity = timestamp;

            // Detect persistence mechanism
            if is_autostart {
                self.detect_persistence_mechanism(pid, key_path);
            }

            self.cleanup_old_events(pid);
        }
    }

    /// Detect process bombing (rapid child process creation)
    fn detect_process_bombing(&mut self, pid: u32) {
        if let Some(behavior) = self.processes.get(&pid) {
            let recent_processes = behavior.events.iter()
                .filter(|e| e.event_type == BehaviorEventType::ProcessCreation)
                .filter(|e| Self::current_timestamp() - e.timestamp < 10)
                .count();

            if recent_processes > 10 {
                log::warn!(
                    "⚠️  Process bombing detected: {} (PID {}) created {} processes in 10s",
                    behavior.name,
                    pid,
                    recent_processes
                );

                self.create_detection(
                    pid,
                    BehaviorType::ProcessBombing,
                    80.0,
                    0.90,
                    "T1106", // Native API
                    vec![
                        BehaviorIndicator {
                            indicator_type: "rapid_process_creation".to_string(),
                            value: format!("{} processes in 10 seconds", recent_processes),
                            weight: 40.0,
                            timestamp: Self::current_timestamp(),
                        },
                    ],
                    format!("Rapid process creation detected ({} processes)", recent_processes),
                );
            }
        }
    }

    /// Detect ransomware behavior
    fn detect_ransomware_behavior(&mut self, pid: u32) {
        if let Some(behavior) = self.processes.get(&pid) {
            let recent_encryptions = behavior.events.iter()
                .filter(|e| e.event_type == BehaviorEventType::FileEncryption)
                .filter(|e| Self::current_timestamp() - e.timestamp < 60)
                .count();

            let recent_deletes = behavior.events.iter()
                .filter(|e| e.event_type == BehaviorEventType::FileDelete)
                .filter(|e| Self::current_timestamp() - e.timestamp < 60)
                .count();

            if recent_encryptions > 5 || recent_deletes > 20 {
                log::warn!(
                    "⚠️  Ransomware behavior detected: {} (PID {}) - {} encryptions, {} deletes",
                    behavior.name,
                    pid,
                    recent_encryptions,
                    recent_deletes
                );

                self.create_detection(
                    pid,
                    BehaviorType::RansomwareBehavior,
                    95.0,
                    0.95,
                    "T1486", // Data Encrypted for Impact
                    vec![
                        BehaviorIndicator {
                            indicator_type: "mass_file_encryption".to_string(),
                            value: format!("{} files encrypted", recent_encryptions),
                            weight: 50.0,
                            timestamp: Self::current_timestamp(),
                        },
                        BehaviorIndicator {
                            indicator_type: "mass_file_deletion".to_string(),
                            value: format!("{} files deleted", recent_deletes),
                            weight: 30.0,
                            timestamp: Self::current_timestamp(),
                        },
                    ],
                    "Ransomware-like file encryption/deletion detected".to_string(),
                );
            }
        }
    }

    /// Detect credential access
    fn detect_credential_access(&mut self, pid: u32, file_path: &str) {
        if let Some(behavior) = self.processes.get(&pid) {
            log::warn!(
                "⚠️  Credential access detected: {} (PID {}) accessing {}",
                behavior.name,
                pid,
                file_path
            );

            self.create_detection(
                pid,
                BehaviorType::CredentialAccess,
                85.0,
                0.85,
                "T1003", // OS Credential Dumping
                vec![
                    BehaviorIndicator {
                        indicator_type: "sensitive_file_access".to_string(),
                        value: file_path.to_string(),
                        weight: 45.0,
                        timestamp: Self::current_timestamp(),
                    },
                ],
                format!("Access to credential file: {}", file_path),
            );
        }
    }

    /// Detect C2 communication
    fn detect_c2_communication(&mut self, pid: u32, remote_ip: &str) {
        if let Some(behavior) = self.processes.get(&pid) {
            let threat_desc = self.known_bad_ips.get(remote_ip)
                .cloned()
                .unwrap_or_else(|| "Unknown threat".to_string());

            log::warn!(
                "⚠️  C2 communication detected: {} (PID {}) -> {} ({})",
                behavior.name,
                pid,
                remote_ip,
                threat_desc
            );

            self.create_detection(
                pid,
                BehaviorType::CommandAndControl,
                90.0,
                0.92,
                "T1071", // Application Layer Protocol
                vec![
                    BehaviorIndicator {
                        indicator_type: "known_malicious_ip".to_string(),
                        value: remote_ip.to_string(),
                        weight: 50.0,
                        timestamp: Self::current_timestamp(),
                    },
                ],
                format!("Connection to known C2 server: {} ({})", remote_ip, threat_desc),
            );
        }
    }

    /// Detect persistence mechanism
    fn detect_persistence_mechanism(&mut self, pid: u32, registry_path: &str) {
        if let Some(behavior) = self.processes.get(&pid) {
            log::warn!(
                "⚠️  Persistence mechanism detected: {} (PID {}) modifying {}",
                behavior.name,
                pid,
                registry_path
            );

            self.create_detection(
                pid,
                BehaviorType::PersistenceMechanism,
                75.0,
                0.80,
                "T1547", // Boot or Logon Autostart Execution
                vec![
                    BehaviorIndicator {
                        indicator_type: "autostart_registry_modification".to_string(),
                        value: registry_path.to_string(),
                        weight: 35.0,
                        timestamp: Self::current_timestamp(),
                    },
                ],
                format!("Autostart registry key modified: {}", registry_path),
            );
        }
    }

    /// Create behavioral detection
    fn create_detection(
        &mut self,
        pid: u32,
        behavior_type: BehaviorType,
        risk_score: f32,
        confidence: f32,
        mitre_technique: &str,
        indicators: Vec<BehaviorIndicator>,
        description: String,
    ) {
        let process_name = self.processes.get(&pid)
            .map(|b| b.name.clone())
            .unwrap_or_else(|| format!("process_{}", pid));

        let severity = if risk_score >= 90.0 {
            "critical"
        } else if risk_score >= 70.0 {
            "high"
        } else if risk_score >= 50.0 {
            "medium"
        } else {
            "low"
        };

        let detection = BehavioralDetection {
            process_id: pid,
            process_name,
            behavior_type,
            severity: severity.to_string(),
            confidence,
            risk_score,
            timestamp: Self::current_timestamp(),
            mitre_technique: Some(mitre_technique.to_string()),
            indicators,
            description,
        };

        self.detections.push(detection);
    }

    /// Get all detections
    pub fn get_detections(&self) -> &[BehavioralDetection] {
        &self.detections
    }

    /// Get recent detections
    pub fn get_recent_detections(&self, count: usize) -> Vec<BehavioralDetection> {
        self.detections.iter()
            .rev()
            .take(count)
            .cloned()
            .collect()
    }

    /// Get detections by behavior type
    pub fn get_detections_by_type(&self, behavior_type: &BehaviorType) -> Vec<BehavioralDetection> {
        self.detections.iter()
            .filter(|d| &d.behavior_type == behavior_type)
            .cloned()
            .collect()
    }

    /// Clear old detections
    pub fn clear_old_detections(&mut self, older_than_seconds: i64) {
        let cutoff_time = Self::current_timestamp() - older_than_seconds;
        self.detections.retain(|d| d.timestamp > cutoff_time);
    }

    /// Get detection statistics
    pub fn get_stats(&self) -> BehavioralStats {
        let mut stats = BehavioralStats {
            total_detections: self.detections.len(),
            by_behavior_type: HashMap::new(),
            by_severity: HashMap::new(),
            high_risk_count: 0,
            avg_risk_score: 0.0,
        };

        let mut total_risk = 0.0;

        for detection in &self.detections {
            // Count by behavior type
            *stats.by_behavior_type.entry(format!("{:?}", detection.behavior_type)).or_insert(0) += 1;

            // Count by severity
            *stats.by_severity.entry(detection.severity.clone()).or_insert(0) += 1;

            // High risk count
            if detection.risk_score >= 80.0 {
                stats.high_risk_count += 1;
            }

            total_risk += detection.risk_score;
        }

        if !self.detections.is_empty() {
            stats.avg_risk_score = total_risk / self.detections.len() as f32;
        }

        stats
    }

    /// Load sensitive file paths
    fn load_sensitive_paths(&mut self) {
        #[cfg(target_os = "linux")]
        {
            self.sensitive_paths = vec![
                "/etc/shadow".to_string(),
                "/etc/passwd".to_string(),
                "/etc/sudoers".to_string(),
                "/root/.ssh/".to_string(),
                "/home/*/.ssh/".to_string(),
                "/etc/pam.d/".to_string(),
            ];
        }

        #[cfg(target_os = "windows")]
        {
            self.sensitive_paths = vec![
                "C:\\Windows\\System32\\config\\SAM".to_string(),
                "C:\\Windows\\System32\\config\\SYSTEM".to_string(),
                "C:\\Windows\\System32\\config\\SECURITY".to_string(),
                "lsass.exe".to_string(),
            ];
        }

        log::debug!("Loaded {} sensitive paths", self.sensitive_paths.len());
    }

    /// Load threat intelligence (known bad IPs, etc.)
    fn load_threat_intelligence(&mut self) {
        // TODO: Load from threat intel feeds
        // For now, use some example known-bad IPs
        self.known_bad_ips.insert("198.51.100.1".to_string(), "Example C2 server".to_string());
        self.known_bad_ips.insert("203.0.113.1".to_string(), "Known malware infrastructure".to_string());

        log::debug!("Loaded {} known bad IPs", self.known_bad_ips.len());
    }

    /// Check if path is sensitive
    fn is_sensitive_path(&self, path: &str) -> bool {
        self.sensitive_paths.iter().any(|sp| path.contains(sp))
    }

    /// Check if process is trusted
    fn is_trusted_process(&self, process_name: &str) -> bool {
        self.config.trusted_processes.contains(&process_name.to_string())
    }

    /// Cleanup old events for a process
    fn cleanup_old_events(&mut self, pid: u32) {
        if let Some(behavior) = self.processes.get_mut(&pid) {
            let cutoff_time = Self::current_timestamp() - self.config.analysis_window as i64;

            // Remove old events
            behavior.events.retain(|e| e.timestamp > cutoff_time);

            // Limit event count
            while behavior.events.len() > self.config.max_events_per_process {
                behavior.events.pop_front();
            }

            // Recalculate risk score
            let total_weight: f32 = behavior.events.iter().map(|e| e.weight).sum();
            behavior.risk_score = total_weight.min(100.0);
        }
    }

    /// Get current Unix timestamp
    fn current_timestamp() -> i64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64
    }
}

/// Behavioral detection statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct BehavioralStats {
    pub total_detections: usize,
    pub by_behavior_type: HashMap<String, usize>,
    pub by_severity: HashMap<String, usize>,
    pub high_risk_count: usize,
    pub avg_risk_score: f32,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_behavioral_engine_creation() {
        let config = BehavioralConfig::default();
        let engine = BehavioralEngine::new(config);

        assert_eq!(engine.detections.len(), 0);
        assert!(engine.sensitive_paths.len() > 0);
    }

    #[test]
    fn test_process_creation_tracking() {
        let config = BehavioralConfig::default();
        let mut engine = BehavioralEngine::new(config);

        engine.record_process_creation(
            1234,
            "test_process".to_string(),
            1,
            "/bin/test".to_string(),
        );

        assert!(engine.processes.contains_key(&1234));
    }

    #[test]
    fn test_trusted_process_check() {
        let config = BehavioralConfig::default();
        let engine = BehavioralEngine::new(config);

        assert!(engine.is_trusted_process("systemd"));
        assert!(!engine.is_trusted_process("malware.exe"));
    }

    #[test]
    fn test_sensitive_path_detection() {
        let config = BehavioralConfig::default();
        let engine = BehavioralEngine::new(config);

        #[cfg(target_os = "linux")]
        {
            assert!(engine.is_sensitive_path("/etc/shadow"));
            assert!(!engine.is_sensitive_path("/tmp/test.txt"));
        }
    }
}
