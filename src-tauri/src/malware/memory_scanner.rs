/*!
 * Advanced Memory Scanner
 *
 * Detects in-memory threats that file-based scanners miss:
 * - Process injection (CreateRemoteThread, DLL injection, reflective loading)
 * - Process hollowing and doppelganging
 * - Shellcode execution
 * - Fileless malware
 * - Malicious payloads in memory
 * - ROP chains and exploit primitives
 *
 * This rivals CrowdStrike's memory protection capabilities.
 */

use std::collections::HashMap;
use std::path::PathBuf;
use serde::{Serialize, Deserialize};

#[cfg(target_os = "linux")]
use std::fs;

#[cfg(target_os = "linux")]
use libc::{iovec, pid_t, c_void, size_t};

// Linux process_vm_readv syscall number
#[cfg(target_os = "linux")]
const SYS_PROCESS_VM_READV: i64 = 310;

/// Memory region information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryRegion {
    pub start_address: u64,
    pub end_address: u64,
    pub size: usize,
    pub permissions: String, // "r-x", "rw-", "rwx", etc.
    pub path: Option<PathBuf>,
    pub is_executable: bool,
    pub is_writable: bool,
}

/// Memory scan result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryScanResult {
    pub process_id: u32,
    pub process_name: String,
    pub is_malicious: bool,
    pub threats_found: Vec<MemoryThreat>,
    pub scan_duration_ms: u64,
    pub regions_scanned: usize,
}

/// Memory threat types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryThreat {
    pub threat_type: MemoryThreatType,
    pub severity: String, // "critical", "high", "medium", "low"
    pub description: String,
    pub memory_region: MemoryRegion,
    pub indicators: Vec<String>,
    pub mitre_technique: Option<String>, // MITRE ATT&CK technique ID
}

/// Types of memory-based threats
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MemoryThreatType {
    /// Code injection via CreateRemoteThread
    ProcessInjection,

    /// DLL injection
    DllInjection,

    /// Reflective DLL loading
    ReflectiveDllInjection,

    /// Process hollowing (replace legitimate process with malicious code)
    ProcessHollowing,

    /// Process doppelganging
    ProcessDoppelganging,

    /// Shellcode detected in memory
    ShellcodeExecution,

    /// Suspicious RWX (Read-Write-Execute) memory region
    SuspiciousRwxMemory,

    /// Known malware signature in memory
    MalwareSignature,

    /// ROP (Return-Oriented Programming) chain detected
    RopChain,

    /// Heap spray detected
    HeapSpray,

    /// Fileless malware (no file on disk)
    FilelessMalware,
}

/// Memory scanner configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryScanConfig {
    /// Scan for shellcode patterns
    pub detect_shellcode: bool,

    /// Detect RWX memory regions
    pub detect_rwx_regions: bool,

    /// Scan for known malware signatures
    pub scan_signatures: bool,

    /// Detect process injection
    pub detect_injection: bool,

    /// Maximum memory to scan per process (MB)
    pub max_memory_per_process: usize,

    /// Scan timeout per process (seconds)
    pub scan_timeout: u64,
}

impl Default for MemoryScanConfig {
    fn default() -> Self {
        Self {
            detect_shellcode: true,
            detect_rwx_regions: true,
            scan_signatures: true,
            detect_injection: true,
            max_memory_per_process: 500, // 500MB
            scan_timeout: 30, // 30 seconds
        }
    }
}

/// Advanced memory scanner
pub struct MemoryScanner {
    config: MemoryScanConfig,
}

impl MemoryScanner {
    /// Create new memory scanner
    pub fn new(config: MemoryScanConfig) -> Self {
        Self { config }
    }

    /// Scan a specific process by PID
    pub fn scan_process(&self, pid: u32) -> Result<MemoryScanResult, String> {
        let start_time = std::time::Instant::now();

        log::info!("Starting memory scan for PID {}", pid);

        // Get process name
        let process_name = self.get_process_name(pid)?;

        // Get memory regions
        let regions = self.get_memory_regions(pid)?;

        log::debug!("Found {} memory regions for PID {}", regions.len(), pid);

        let mut threats = Vec::new();

        // Scan each memory region
        for region in &regions {
            // Check for RWX regions (highly suspicious)
            if self.config.detect_rwx_regions && self.is_rwx_region(region) {
                threats.push(MemoryThreat {
                    threat_type: MemoryThreatType::SuspiciousRwxMemory,
                    severity: "high".to_string(),
                    description: format!(
                        "Suspicious RWX memory region at 0x{:x} ({})",
                        region.start_address,
                        region.path.as_ref().map(|p| p.display().to_string()).unwrap_or_else(|| "anonymous".to_string())
                    ),
                    memory_region: region.clone(),
                    indicators: vec![
                        "Read+Write+Execute permissions".to_string(),
                        "Potential code injection".to_string(),
                    ],
                    mitre_technique: Some("T1055".to_string()), // Process Injection
                });
            }

            // Detect shellcode patterns
            if self.config.detect_shellcode {
                if let Some(shellcode_threat) = self.detect_shellcode(region, pid) {
                    threats.push(shellcode_threat);
                }
            }

            // Detect process injection
            if self.config.detect_injection {
                if let Some(injection_threat) = self.detect_injection(region, pid) {
                    threats.push(injection_threat);
                }
            }
        }

        let duration = start_time.elapsed().as_millis() as u64;
        let is_malicious = !threats.is_empty();

        if is_malicious {
            log::warn!(
                "⚠️  Memory threats detected in {} (PID {}): {} threat(s)",
                process_name,
                pid,
                threats.len()
            );
        }

        Ok(MemoryScanResult {
            process_id: pid,
            process_name,
            is_malicious,
            threats_found: threats,
            scan_duration_ms: duration,
            regions_scanned: regions.len(),
        })
    }

    /// Scan all running processes
    pub fn scan_all_processes(&self) -> Vec<MemoryScanResult> {
        let mut results = Vec::new();

        // Get all running PIDs
        let pids = self.get_all_pids();

        log::info!("Scanning {} processes", pids.len());

        for pid in pids {
            match self.scan_process(pid) {
                Ok(result) => {
                    if result.is_malicious {
                        log::warn!(
                            "Threats found in {} (PID {}): {}",
                            result.process_name,
                            result.process_id,
                            result.threats_found.len()
                        );
                    }
                    results.push(result);
                }
                Err(e) => {
                    log::debug!("Failed to scan PID {}: {}", pid, e);
                }
            }
        }

        results
    }

    /// Get memory regions for a process
    #[cfg(target_os = "linux")]
    fn get_memory_regions(&self, pid: u32) -> Result<Vec<MemoryRegion>, String> {
        let maps_path = format!("/proc/{}/maps", pid);
        let maps_content = fs::read_to_string(&maps_path)
            .map_err(|e| format!("Failed to read {}: {}", maps_path, e))?;

        let mut regions = Vec::new();

        for line in maps_content.lines() {
            if let Some(region) = self.parse_memory_map_line(line) {
                regions.push(region);
            }
        }

        Ok(regions)
    }

    #[cfg(target_os = "windows")]
    fn get_memory_regions(&self, pid: u32) -> Result<Vec<MemoryRegion>, String> {
        // TODO: Use Windows API (VirtualQueryEx) to enumerate memory regions
        Ok(Vec::new())
    }

    /// Parse Linux /proc/[pid]/maps line
    #[cfg(target_os = "linux")]
    fn parse_memory_map_line(&self, line: &str) -> Option<MemoryRegion> {
        // Format: address perms offset dev inode pathname
        // Example: 7f1234567000-7f1234568000 r-xp 00000000 08:01 12345 /lib/x86_64-linux-gnu/libc-2.31.so

        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() < 2 {
            return None;
        }

        // Parse address range
        let addresses: Vec<&str> = parts[0].split('-').collect();
        if addresses.len() != 2 {
            return None;
        }

        let start_address = u64::from_str_radix(addresses[0], 16).ok()?;
        let end_address = u64::from_str_radix(addresses[1], 16).ok()?;
        let size = (end_address - start_address) as usize;

        // Parse permissions
        let permissions = parts[1].to_string();
        let is_executable = permissions.contains('x');
        let is_writable = permissions.contains('w');

        // Parse path (if exists)
        let path = if parts.len() >= 6 {
            Some(PathBuf::from(parts[5]))
        } else {
            None
        };

        Some(MemoryRegion {
            start_address,
            end_address,
            size,
            permissions,
            path,
            is_executable,
            is_writable,
        })
    }

    /// Check if memory region has RWX permissions (suspicious)
    fn is_rwx_region(&self, region: &MemoryRegion) -> bool {
        region.is_executable && region.is_writable
    }

    /// Detect shellcode patterns in memory
    fn detect_shellcode(&self, region: &MemoryRegion, pid: u32) -> Option<MemoryThreat> {
        // Only scan executable regions
        if !region.is_executable {
            return None;
        }

        // Skip mapped files (likely legitimate libraries)
        if region.path.is_some() {
            return None;
        }

        // Read memory and scan for shellcode patterns
        let memory_data = match self.read_process_memory(pid, region.start_address, region.size) {
            Ok(data) => data,
            Err(e) => {
                log::debug!("Failed to read memory at 0x{:x}: {}", region.start_address, e);
                return None;
            }
        };

        let mut indicators = vec!["Anonymous executable memory".to_string()];
        let mut severity = "medium";

        // Check for common shellcode patterns
        if self.contains_shellcode_patterns(&memory_data) {
            indicators.push("Shellcode instruction patterns detected".to_string());
            severity = "high";
        }

        // Check for NOP sleds (common in exploits)
        if self.contains_nop_sled(&memory_data) {
            indicators.push("NOP sled detected (exploit technique)".to_string());
            severity = "high";
        }

        // Check for suspicious PE headers (reflective DLL loading)
        if self.contains_pe_header(&memory_data) {
            indicators.push("PE header in anonymous memory (reflective loading)".to_string());
            severity = "critical";
        }

        // Only report if we found actual suspicious patterns
        if indicators.len() > 1 {
            Some(MemoryThreat {
                threat_type: MemoryThreatType::ShellcodeExecution,
                severity: severity.to_string(),
                description: format!(
                    "Shellcode detected in memory at 0x{:x}",
                    region.start_address
                ),
                memory_region: region.clone(),
                indicators,
                mitre_technique: Some("T1055.001".to_string()), // Dynamic-link Library Injection
            })
        } else {
            None
        }
    }

    /// Detect process injection indicators
    fn detect_injection(&self, region: &MemoryRegion, pid: u32) -> Option<MemoryThreat> {
        // Check for common injection indicators:
        // 1. Executable memory without a backing file
        // 2. Writable + executable memory
        // 3. Memory regions in suspicious locations

        if region.is_executable && region.path.is_none() && region.is_writable {
            return Some(MemoryThreat {
                threat_type: MemoryThreatType::ProcessInjection,
                severity: "critical".to_string(),
                description: format!(
                    "Process injection detected at 0x{:x}",
                    region.start_address
                ),
                memory_region: region.clone(),
                indicators: vec![
                    "RWX memory without backing file".to_string(),
                    "Typical of CreateRemoteThread injection".to_string(),
                ],
                mitre_technique: Some("T1055".to_string()),
            });
        }

        None
    }

    /// Get process name by PID
    #[cfg(target_os = "linux")]
    fn get_process_name(&self, pid: u32) -> Result<String, String> {
        let comm_path = format!("/proc/{}/comm", pid);
        fs::read_to_string(&comm_path)
            .map(|s| s.trim().to_string())
            .map_err(|e| format!("Failed to read process name: {}", e))
    }

    #[cfg(target_os = "windows")]
    fn get_process_name(&self, pid: u32) -> Result<String, String> {
        // TODO: Use Windows API to get process name
        Ok(format!("process_{}", pid))
    }

    /// Get all running process IDs
    #[cfg(target_os = "linux")]
    fn get_all_pids(&self) -> Vec<u32> {
        let mut pids = Vec::new();

        if let Ok(entries) = fs::read_dir("/proc") {
            for entry in entries.flatten() {
                if let Ok(file_name) = entry.file_name().into_string() {
                    if let Ok(pid) = file_name.parse::<u32>() {
                        pids.push(pid);
                    }
                }
            }
        }

        pids
    }

    #[cfg(target_os = "windows")]
    fn get_all_pids(&self) -> Vec<u32> {
        // TODO: Use Windows API to enumerate processes
        Vec::new()
    }

    /// Get memory scan statistics
    pub fn get_stats(&self) -> MemoryScanStats {
        MemoryScanStats {
            total_processes_scanned: 0, // TODO: Track this
            threats_detected: 0, // TODO: Track this
            shellcode_detections: 0,
            injection_detections: 0,
            rwx_regions_found: 0,
        }
    }

    // ========== Memory Reading Implementation ==========

    /// Read process memory using process_vm_readv (Linux)
    #[cfg(target_os = "linux")]
    fn read_process_memory(&self, pid: u32, address: u64, size: usize) -> Result<Vec<u8>, String> {
        // Limit memory read size to prevent excessive memory usage
        let read_size = std::cmp::min(size, self.config.max_memory_per_process * 1024 * 1024);

        // Skip very small regions
        if read_size < 16 {
            return Err("Region too small".to_string());
        }

        let mut buffer = vec![0u8; read_size];

        unsafe {
            let local_iov = iovec {
                iov_base: buffer.as_mut_ptr() as *mut c_void,
                iov_len: read_size as size_t,
            };

            let remote_iov = iovec {
                iov_base: address as *mut c_void,
                iov_len: read_size as size_t,
            };

            let result = libc::syscall(
                SYS_PROCESS_VM_READV,
                pid as pid_t,
                &local_iov as *const iovec,
                1usize, // local_iovcnt
                &remote_iov as *const iovec,
                1usize, // remote_iovcnt
                0usize, // flags
            );

            if result < 0 {
                return Err(format!("process_vm_readv failed: {}", std::io::Error::last_os_error()));
            }

            if result == 0 {
                return Err("No bytes read".to_string());
            }

            // Truncate buffer to actual bytes read
            buffer.truncate(result as usize);
        }

        Ok(buffer)
    }

    #[cfg(target_os = "windows")]
    fn read_process_memory(&self, pid: u32, address: u64, size: usize) -> Result<Vec<u8>, String> {
        // TODO: Implement using ReadProcessMemory API
        Err("Not implemented on Windows".to_string())
    }

    // ========== Pattern Detection Functions ==========

    /// Detect common shellcode instruction patterns
    fn contains_shellcode_patterns(&self, data: &[u8]) -> bool {
        // Common x86/x64 shellcode patterns
        let patterns: Vec<&[u8]> = vec![
            // GetProcAddress pattern (kernel32 API resolution)
            &[0x64u8, 0xA1, 0x30, 0x00, 0x00, 0x00], // mov eax, fs:[0x30]
            &[0x8Bu8, 0x40, 0x0C], // mov eax, [eax+0xc]

            // Common syscall patterns
            &[0x0Fu8, 0x05], // syscall
            &[0xCDu8, 0x80], // int 0x80
            &[0xCDu8, 0x2E], // int 0x2e

            // WinExec pattern
            &[0x57u8, 0x69, 0x6E, 0x45, 0x78, 0x65, 0x63], // "WinExec"

            // LoadLibraryA pattern
            &[0x4Cu8, 0x6F, 0x61, 0x64, 0x4C, 0x69, 0x62], // "LoadLib"

            // CreateProcessA pattern
            &[0x43u8, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50], // "CreateP"

            // Common stack pivot patterns
            &[0x94u8], // xchg eax, esp
            &[0x87u8, 0xE0], // xchg eax, esp (alternative)

            // Common XOR decoder loop (shellcode decryption)
            &[0x31u8, 0xC9], // xor ecx, ecx
            &[0x30u8, 0x04, 0x0E], // xor [esi+ecx], al
        ];

        for pattern in &patterns {
            if self.find_bytes(data, pattern) {
                return true;
            }
        }

        false
    }

    /// Detect NOP sleds (common in buffer overflow exploits)
    fn contains_nop_sled(&self, data: &[u8]) -> bool {
        if data.len() < 32 {
            return false;
        }

        // Look for consecutive NOP instructions (0x90)
        let mut nop_count = 0;
        let mut max_nop_count = 0;

        for byte in data {
            if *byte == 0x90 {
                nop_count += 1;
                max_nop_count = std::cmp::max(max_nop_count, nop_count);
            } else {
                nop_count = 0;
            }
        }

        // 16+ consecutive NOPs is very suspicious
        max_nop_count >= 16
    }

    /// Detect PE headers (Windows executable in memory - reflective loading)
    fn contains_pe_header(&self, data: &[u8]) -> bool {
        if data.len() < 64 {
            return false;
        }

        // Check for MZ header
        if data[0] == 0x4D && data[1] == 0x5A {
            // Check for PE signature
            if data.len() >= 0x3C + 4 {
                let pe_offset = u32::from_le_bytes([data[0x3C], data[0x3D], data[0x3E], data[0x3F]]) as usize;

                if pe_offset < data.len() - 4 {
                    // Check for "PE\0\0" signature
                    if data[pe_offset] == 0x50 && data[pe_offset + 1] == 0x45 &&
                       data[pe_offset + 2] == 0x00 && data[pe_offset + 3] == 0x00 {
                        return true;
                    }
                }
            }
        }

        false
    }

    /// Find byte pattern in data
    fn find_bytes(&self, haystack: &[u8], needle: &[u8]) -> bool {
        if needle.is_empty() || haystack.len() < needle.len() {
            return false;
        }

        for i in 0..=haystack.len() - needle.len() {
            if &haystack[i..i + needle.len()] == needle {
                return true;
            }
        }

        false
    }
}

/// Memory scan statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct MemoryScanStats {
    pub total_processes_scanned: usize,
    pub threats_detected: usize,
    pub shellcode_detections: usize,
    pub injection_detections: usize,
    pub rwx_regions_found: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_memory_scanner_creation() {
        let config = MemoryScanConfig::default();
        let scanner = MemoryScanner::new(config);
        assert!(scanner.config.detect_shellcode);
        assert!(scanner.config.detect_rwx_regions);
    }

    #[test]
    #[cfg(target_os = "linux")]
    fn test_parse_memory_map_line() {
        let scanner = MemoryScanner::new(MemoryScanConfig::default());
        let line = "7f1234567000-7f1234568000 r-xp 00000000 08:01 12345 /lib/x86_64-linux-gnu/libc.so";

        let region = scanner.parse_memory_map_line(line).unwrap();

        assert_eq!(region.start_address, 0x7f1234567000);
        assert_eq!(region.end_address, 0x7f1234568000);
        assert!(region.is_executable);
        assert!(!region.is_writable);
    }

    #[test]
    fn test_rwx_detection() {
        let scanner = MemoryScanner::new(MemoryScanConfig::default());

        let rwx_region = MemoryRegion {
            start_address: 0x1000,
            end_address: 0x2000,
            size: 0x1000,
            permissions: "rwxp".to_string(),
            path: None,
            is_executable: true,
            is_writable: true,
        };

        assert!(scanner.is_rwx_region(&rwx_region));
    }
}
