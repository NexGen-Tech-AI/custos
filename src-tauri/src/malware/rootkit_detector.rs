/*!
 * Rootkit Detection Engine
 *
 * Advanced rootkit detection capabilities:
 * - Kernel module integrity verification
 * - Hidden process detection (cross-validation)
 * - Hidden file detection via discrepancy analysis
 * - System call hook detection
 * - Driver verification and signing checks
 * - Memory manipulation detection
 * - Bootkit and firmware rootkit detection
 */

use std::collections::{HashMap, HashSet};
use std::path::{Path, PathBuf};
use std::fs;
use serde::{Serialize, Deserialize};

#[cfg(target_os = "linux")]
use std::process::Command;

/// Rootkit detection engine
pub struct RootKitDetector {
    baseline: SystemBaseline,
    detections: Vec<RootkitDetection>,
    kernel_modules: Vec<KernelModule>,
    suspicious_drivers: Vec<SuspiciousDriver>,
    config: RootkitDetectorConfig,
}

/// Rootkit detector configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RootkitDetectorConfig {
    pub enabled: bool,
    pub deep_scan: bool,
    pub check_kernel_modules: bool,
    pub check_hidden_processes: bool,
    pub check_hidden_files: bool,
    pub check_syscall_hooks: bool,
    pub check_drivers: bool,
    pub baseline_on_startup: bool,
}

impl Default for RootkitDetectorConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            deep_scan: true,
            check_kernel_modules: true,
            check_hidden_processes: true,
            check_hidden_files: true,
            check_syscall_hooks: true,
            check_drivers: true,
            baseline_on_startup: true,
        }
    }
}

/// System baseline for integrity checking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemBaseline {
    pub created_at: i64,
    pub kernel_modules: HashMap<String, ModuleInfo>,
    pub system_files: HashMap<PathBuf, FileInfo>,
    pub process_list: HashSet<u32>,
    pub loaded_drivers: Vec<String>,
}

/// Kernel module information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KernelModule {
    pub name: String,
    pub size: u64,
    pub used_by: Vec<String>,
    pub status: ModuleStatus,
    pub path: Option<PathBuf>,
    pub signature_valid: bool,
    pub suspicious_score: f64,
}

/// Module status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ModuleStatus {
    Clean,
    Suspicious,
    Malicious,
    Unknown,
}

/// Module information for baseline
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleInfo {
    pub size: u64,
    pub hash: String,
    pub loaded_at: i64,
}

/// File information for baseline
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileInfo {
    pub size: u64,
    pub hash: String,
    pub modified: i64,
    pub permissions: u32,
}

/// Suspicious driver
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuspiciousDriver {
    pub name: String,
    pub path: PathBuf,
    pub signed: bool,
    pub signer: Option<String>,
    pub loaded_at: i64,
    pub suspicious_reasons: Vec<String>,
}

/// Rootkit detection result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RootkitDetection {
    pub id: String,
    pub detected_at: i64,
    pub rootkit_type: RootkitType,
    pub severity: DetectionSeverity,
    pub confidence: f64,
    pub indicators: Vec<RootkitIndicator>,
    pub affected_resources: Vec<String>,
    pub remediation: Vec<String>,
}

/// Type of rootkit detected
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RootkitType {
    UserMode,           // User-space rootkit
    KernelMode,         // Kernel-space rootkit
    Bootkit,            // Boot sector/firmware rootkit
    HybridMode,         // Combined user + kernel
    Hypervisor,         // Hypervisor-based (Blue Pill)
    Firmware,           // UEFI/BIOS rootkit
}

/// Detection severity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]
pub enum DetectionSeverity {
    Critical,   // Active rootkit with kernel access
    High,       // Likely rootkit with system modifications
    Medium,     // Suspicious behavior requiring investigation
    Low,        // Anomalies detected
}

/// Rootkit indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RootkitIndicator {
    HiddenProcess { pid: u32, name: String },
    HiddenFile { path: PathBuf },
    HiddenModule { name: String },
    ModifiedSystemFile { path: PathBuf, original_hash: String, current_hash: String },
    SyscallHook { syscall: String, hooked_address: String },
    UnsignedDriver { path: PathBuf },
    SuspiciousDriver { name: String, reason: String },
    MemoryAnomalyDetected { address: String, reason: String },
    DirectKernelMemoryAccess { process: String },
    InlineFunctionHook { function: String },
}

/// Hidden process detection result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HiddenProcess {
    pub pid: u32,
    pub name: String,
    pub detection_method: DetectionMethod,
    pub confidence: f64,
}

/// Detection method used
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DetectionMethod {
    ProcFsDiscrepancy,      // /proc vs ps discrepancy
    TaskStructWalk,         // Direct kernel task_struct walk
    SocketListDiscrepancy,  // Network connection vs process list
    HandleTableScan,        // Handle table enumeration
    PspcidlistScan,         // Windows EPROCESS list
}

impl RootKitDetector {
    /// Create new rootkit detector
    pub fn new(config: RootkitDetectorConfig) -> Result<Self, String> {
        log::info!("ðŸ” Initializing rootkit detector");

        let baseline = if config.baseline_on_startup {
            Self::create_baseline()?
        } else {
            SystemBaseline {
                created_at: Self::current_timestamp(),
                kernel_modules: HashMap::new(),
                system_files: HashMap::new(),
                process_list: HashSet::new(),
                loaded_drivers: Vec::new(),
            }
        };

        log::info!("âœ… Rootkit detector initialized");

        Ok(Self {
            baseline,
            detections: Vec::new(),
            kernel_modules: Vec::new(),
            suspicious_drivers: Vec::new(),
            config,
        })
    }

    /// Create system baseline
    fn create_baseline() -> Result<SystemBaseline, String> {
        log::info!("ðŸ“Š Creating system baseline for integrity verification");

        let mut baseline = SystemBaseline {
            created_at: Self::current_timestamp(),
            kernel_modules: HashMap::new(),
            system_files: HashMap::new(),
            process_list: HashSet::new(),
            loaded_drivers: Vec::new(),
        };

        // Collect kernel modules
        #[cfg(target_os = "linux")]
        {
            if let Ok(modules) = Self::enumerate_kernel_modules_linux() {
                for module in modules {
                    baseline.kernel_modules.insert(
                        module.name.clone(),
                        ModuleInfo {
                            size: module.size,
                            hash: "".to_string(), // TODO: Calculate hash
                            loaded_at: Self::current_timestamp(),
                        },
                    );
                }
            }
        }

        // Collect critical system files
        let critical_paths = Self::get_critical_system_paths();
        for path in critical_paths {
            if let Ok(info) = Self::get_file_info(&path) {
                baseline.system_files.insert(path, info);
            }
        }

        log::info!(
            "âœ… Baseline created: {} modules, {} files",
            baseline.kernel_modules.len(),
            baseline.system_files.len()
        );

        Ok(baseline)
    }

    /// Get critical system paths to monitor
    fn get_critical_system_paths() -> Vec<PathBuf> {
        let mut paths = Vec::new();

        #[cfg(target_os = "linux")]
        {
            paths.extend(vec![
                PathBuf::from("/bin/bash"),
                PathBuf::from("/bin/sh"),
                PathBuf::from("/usr/bin/ps"),
                PathBuf::from("/usr/bin/ls"),
                PathBuf::from("/usr/bin/netstat"),
                PathBuf::from("/sbin/init"),
                PathBuf::from("/lib/x86_64-linux-gnu/libc.so.6"),
                PathBuf::from("/etc/ld.so.preload"),
                PathBuf::from("/etc/hosts"),
            ]);
        }

        #[cfg(target_os = "windows")]
        {
            paths.extend(vec![
                PathBuf::from("C:\\Windows\\System32\\kernel32.dll"),
                PathBuf::from("C:\\Windows\\System32\\ntdll.dll"),
                PathBuf::from("C:\\Windows\\System32\\cmd.exe"),
                PathBuf::from("C:\\Windows\\System32\\taskmgr.exe"),
                PathBuf::from("C:\\Windows\\System32\\drivers\\etc\\hosts"),
            ]);
        }

        paths
    }

    /// Get file information
    fn get_file_info(path: &Path) -> Result<FileInfo, String> {
        let metadata = fs::metadata(path)
            .map_err(|e| format!("Failed to read metadata for {:?}: {}", path, e))?;

        let content = fs::read(path)
            .map_err(|e| format!("Failed to read file {:?}: {}", path, e))?;

        let hash = format!("{:x}", md5::compute(&content));

        Ok(FileInfo {
            size: metadata.len(),
            hash,
            modified: Self::current_timestamp(),
            permissions: 0, // TODO: Get actual permissions
        })
    }

    /// Perform comprehensive rootkit scan
    pub fn scan(&mut self) -> Result<Vec<RootkitDetection>, String> {
        log::info!("ðŸ”Ž Starting comprehensive rootkit scan");

        let mut all_detections = Vec::new();

        // 1. Check for hidden processes
        if self.config.check_hidden_processes {
            log::debug!("Checking for hidden processes...");
            let hidden_procs = self.detect_hidden_processes()?;
            if !hidden_procs.is_empty() {
                all_detections.extend(self.create_detections_from_hidden_processes(hidden_procs));
            }
        }

        // 2. Check kernel modules
        if self.config.check_kernel_modules {
            log::debug!("Checking kernel modules...");
            let module_detections = self.check_kernel_modules()?;
            all_detections.extend(module_detections);
        }

        // 3. Check for hidden files
        if self.config.check_hidden_files {
            log::debug!("Checking for hidden files...");
            let hidden_files = self.detect_hidden_files()?;
            all_detections.extend(hidden_files);
        }

        // 4. Check system call hooks
        if self.config.check_syscall_hooks {
            log::debug!("Checking for syscall hooks...");
            let hook_detections = self.detect_syscall_hooks()?;
            all_detections.extend(hook_detections);
        }

        // 5. Check drivers
        if self.config.check_drivers {
            log::debug!("Checking drivers...");
            let driver_detections = self.check_drivers()?;
            all_detections.extend(driver_detections);
        }

        // 6. Verify system file integrity
        log::debug!("Verifying system file integrity...");
        let integrity_detections = self.verify_system_integrity()?;
        all_detections.extend(integrity_detections);

        self.detections.extend(all_detections.clone());

        log::info!(
            "âœ… Rootkit scan complete: {} detections found",
            all_detections.len()
        );

        Ok(all_detections)
    }

    /// Detect hidden processes using cross-validation
    fn detect_hidden_processes(&self) -> Result<Vec<HiddenProcess>, String> {
        log::debug!("ðŸ” Detecting hidden processes via cross-validation");

        let mut hidden_processes = Vec::new();

        #[cfg(target_os = "linux")]
        {
            // Method 1: Enumerate via /proc
            let proc_pids = Self::enumerate_pids_from_proc()?;

            // Method 2: Enumerate via ps command
            let ps_pids = Self::enumerate_pids_from_ps()?;

            // Method 3: Enumerate via /proc/*/task (thread-based)
            let task_pids = Self::enumerate_pids_from_tasks()?;

            // Find discrepancies (processes visible in one method but not others)
            for pid in &proc_pids {
                if !ps_pids.contains(pid) {
                    // Process in /proc but not in ps output (suspicious!)
                    if let Ok(name) = Self::get_process_name(*pid) {
                        log::warn!("âš ï¸  Hidden process detected: PID {} ({})", pid, name);
                        hidden_processes.push(HiddenProcess {
                            pid: *pid,
                            name,
                            detection_method: DetectionMethod::ProcFsDiscrepancy,
                            confidence: 0.85,
                        });
                    }
                }
            }

            // Check for processes in tasks but not in /proc (advanced hiding)
            for pid in &task_pids {
                if !proc_pids.contains(pid) && !ps_pids.contains(pid) {
                    if let Ok(name) = Self::get_process_name(*pid) {
                        log::error!("ðŸš¨ Advanced hidden process detected: PID {} ({})", pid, name);
                        hidden_processes.push(HiddenProcess {
                            pid: *pid,
                            name,
                            detection_method: DetectionMethod::TaskStructWalk,
                            confidence: 0.95,
                        });
                    }
                }
            }
        }

        #[cfg(target_os = "windows")]
        {
            // Windows-specific hidden process detection
            // TODO: Implement PsEnumProcesses vs NtQuerySystemInformation cross-validation
        }

        Ok(hidden_processes)
    }

    /// Enumerate PIDs from /proc
    #[cfg(target_os = "linux")]
    fn enumerate_pids_from_proc() -> Result<HashSet<u32>, String> {
        let mut pids = HashSet::new();

        let proc_dir = fs::read_dir("/proc")
            .map_err(|e| format!("Failed to read /proc: {}", e))?;

        for entry in proc_dir.flatten() {
            if let Ok(filename) = entry.file_name().into_string() {
                if let Ok(pid) = filename.parse::<u32>() {
                    pids.insert(pid);
                }
            }
        }

        Ok(pids)
    }

    /// Enumerate PIDs from ps command
    #[cfg(target_os = "linux")]
    fn enumerate_pids_from_ps() -> Result<HashSet<u32>, String> {
        let output = Command::new("ps")
            .args(&["-e", "-o", "pid="])
            .output()
            .map_err(|e| format!("Failed to run ps: {}", e))?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let mut pids = HashSet::new();

        for line in stdout.lines() {
            if let Ok(pid) = line.trim().parse::<u32>() {
                pids.insert(pid);
            }
        }

        Ok(pids)
    }

    /// Enumerate PIDs from /proc/*/task
    #[cfg(target_os = "linux")]
    fn enumerate_pids_from_tasks() -> Result<HashSet<u32>, String> {
        let mut pids = HashSet::new();

        let proc_dir = fs::read_dir("/proc")
            .map_err(|e| format!("Failed to read /proc: {}", e))?;

        for entry in proc_dir.flatten() {
            if let Ok(filename) = entry.file_name().into_string() {
                if let Ok(pid) = filename.parse::<u32>() {
                    let task_dir = entry.path().join("task");
                    if let Ok(tasks) = fs::read_dir(task_dir) {
                        for task_entry in tasks.flatten() {
                            if let Ok(task_name) = task_entry.file_name().into_string() {
                                if let Ok(tid) = task_name.parse::<u32>() {
                                    pids.insert(tid);
                                }
                            }
                        }
                    }
                }
            }
        }

        Ok(pids)
    }

    /// Get process name from PID
    #[cfg(target_os = "linux")]
    fn get_process_name(pid: u32) -> Result<String, String> {
        let comm_path = format!("/proc/{}/comm", pid);
        fs::read_to_string(&comm_path)
            .map(|s| s.trim().to_string())
            .map_err(|e| format!("Failed to read {}: {}", comm_path, e))
    }

    /// Check kernel modules for anomalies
    fn check_kernel_modules(&mut self) -> Result<Vec<RootkitDetection>, String> {
        let mut detections = Vec::new();

        #[cfg(target_os = "linux")]
        {
            let current_modules = Self::enumerate_kernel_modules_linux()?;

            for module in &current_modules {
                // Check if module is in baseline
                if !self.baseline.kernel_modules.contains_key(&module.name) {
                    log::warn!("âš ï¸  New kernel module loaded: {}", module.name);

                    // Check for suspicious characteristics
                    let mut suspicious_score = 0.0;
                    let mut indicators = Vec::new();

                    // Indicator 1: Unsigned module
                    if !module.signature_valid {
                        suspicious_score += 0.4;
                        indicators.push(RootkitIndicator::SuspiciousDriver {
                            name: module.name.clone(),
                            reason: "Unsigned kernel module".to_string(),
                        });
                    }

                    // Indicator 2: Suspicious name patterns
                    let suspicious_names = vec!["rootkit", "hidden", "stealth", "keylog", "backdoor"];
                    if suspicious_names.iter().any(|&s| module.name.to_lowercase().contains(s)) {
                        suspicious_score += 0.5;
                        indicators.push(RootkitIndicator::SuspiciousDriver {
                            name: module.name.clone(),
                            reason: "Suspicious module name".to_string(),
                        });
                    }

                    // Indicator 3: Module not in standard paths
                    if let Some(path) = &module.path {
                        if !path.starts_with("/lib/modules") && !path.starts_with("/usr/lib/modules") {
                            suspicious_score += 0.3;
                            indicators.push(RootkitIndicator::SuspiciousDriver {
                                name: module.name.clone(),
                                reason: "Module loaded from non-standard path".to_string(),
                            });
                        }
                    }

                    if suspicious_score >= 0.5 {
                        detections.push(RootkitDetection {
                            id: format!("RK-MOD-{}", Self::current_timestamp()),
                            detected_at: Self::current_timestamp(),
                            rootkit_type: RootkitType::KernelMode,
                            severity: if suspicious_score > 0.8 {
                                DetectionSeverity::Critical
                            } else if suspicious_score > 0.6 {
                                DetectionSeverity::High
                            } else {
                                DetectionSeverity::Medium
                            },
                            confidence: suspicious_score,
                            indicators,
                            affected_resources: vec![module.name.clone()],
                            remediation: vec![
                                format!("Investigate kernel module: {}", module.name),
                                format!("Consider removing module: rmmod {}", module.name),
                                "Review /var/log/kern.log for module loading activity".to_string(),
                            ],
                        });
                    }
                }
            }

            self.kernel_modules = current_modules;
        }

        Ok(detections)
    }

    /// Enumerate kernel modules on Linux
    #[cfg(target_os = "linux")]
    fn enumerate_kernel_modules_linux() -> Result<Vec<KernelModule>, String> {
        let mut modules = Vec::new();

        let proc_modules = fs::read_to_string("/proc/modules")
            .map_err(|e| format!("Failed to read /proc/modules: {}", e))?;

        for line in proc_modules.lines() {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 3 {
                let name = parts[0].to_string();
                let size = parts[1].parse::<u64>().unwrap_or(0);
                let used_by_str = parts.get(3).unwrap_or(&"");
                let used_by: Vec<String> = used_by_str
                    .split(',')
                    .filter(|s| !s.is_empty())
                    .map(|s| s.to_string())
                    .collect();

                // Check if module is signed
                let modinfo_output = Command::new("modinfo")
                    .arg(&name)
                    .output()
                    .ok();

                let signature_valid = modinfo_output
                    .map(|o| {
                        let output_str = String::from_utf8_lossy(&o.stdout);
                        output_str.contains("sig_key") || output_str.contains("signer")
                    })
                    .unwrap_or(false);

                modules.push(KernelModule {
                    name,
                    size,
                    used_by,
                    status: ModuleStatus::Unknown,
                    path: None,
                    signature_valid,
                    suspicious_score: 0.0,
                });
            }
        }

        Ok(modules)
    }

    /// Detect hidden files
    fn detect_hidden_files(&self) -> Result<Vec<RootkitDetection>, String> {
        // TODO: Implement hidden file detection via:
        // - Direct disk scanning vs filesystem API comparison
        // - Inode enumeration vs readdir() comparison
        // - MFT parsing on Windows vs FindFirstFile()
        Ok(Vec::new())
    }

    /// Detect system call hooks
    fn detect_syscall_hooks(&self) -> Result<Vec<RootkitDetection>, String> {
        // TODO: Implement syscall hook detection:
        // - SSDT (System Service Descriptor Table) verification on Windows
        // - sys_call_table verification on Linux
        // - IDT (Interrupt Descriptor Table) hook detection
        Ok(Vec::new())
    }

    /// Check drivers for anomalies
    fn check_drivers(&mut self) -> Result<Vec<RootkitDetection>, String> {
        let mut detections = Vec::new();

        #[cfg(target_os = "windows")]
        {
            // Windows driver checking
            // TODO: Enumerate drivers and check signatures
        }

        Ok(detections)
    }

    /// Verify system file integrity
    fn verify_system_integrity(&self) -> Result<Vec<RootkitDetection>, String> {
        let mut detections = Vec::new();

        for (path, baseline_info) in &self.baseline.system_files {
            if let Ok(current_info) = Self::get_file_info(path) {
                if baseline_info.hash != current_info.hash {
                    log::error!(
                        "ðŸš¨ System file modified: {:?} (hash mismatch)",
                        path
                    );

                    detections.push(RootkitDetection {
                        id: format!("RK-FILE-{}", Self::current_timestamp()),
                        detected_at: Self::current_timestamp(),
                        rootkit_type: RootkitType::UserMode,
                        severity: DetectionSeverity::High,
                        confidence: 0.9,
                        indicators: vec![
                            RootkitIndicator::ModifiedSystemFile {
                                path: path.clone(),
                                original_hash: baseline_info.hash.clone(),
                                current_hash: current_info.hash.clone(),
                            }
                        ],
                        affected_resources: vec![path.to_string_lossy().to_string()],
                        remediation: vec![
                            format!("System file modified: {:?}", path),
                            "Restore file from known good backup".to_string(),
                            "Run integrity checker (e.g., AIDE, Tripwire)".to_string(),
                        ],
                    });
                }
            }
        }

        Ok(detections)
    }

    /// Create detections from hidden processes
    fn create_detections_from_hidden_processes(
        &self,
        hidden_processes: Vec<HiddenProcess>,
    ) -> Vec<RootkitDetection> {
        hidden_processes
            .into_iter()
            .map(|hp| {
                RootkitDetection {
                    id: format!("RK-PROC-{}-{}", hp.pid, Self::current_timestamp()),
                    detected_at: Self::current_timestamp(),
                    rootkit_type: RootkitType::KernelMode,
                    severity: DetectionSeverity::Critical,
                    confidence: hp.confidence,
                    indicators: vec![
                        RootkitIndicator::HiddenProcess {
                            pid: hp.pid,
                            name: hp.name.clone(),
                        }
                    ],
                    affected_resources: vec![format!("PID {}", hp.pid)],
                    remediation: vec![
                        format!("Hidden process detected: {} (PID {})", hp.name, hp.pid),
                        format!("Terminate process: kill -9 {}", hp.pid),
                        "Investigate process origin and parent".to_string(),
                        "Check for kernel module rootkits (lsmod, /proc/modules)".to_string(),
                        "Consider running chkrootkit or rkhunter".to_string(),
                    ],
                }
            })
            .collect()
    }

    /// Get current timestamp
    fn current_timestamp() -> i64 {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64
    }

    /// Get detection statistics
    pub fn get_stats(&self) -> RootkitStats {
        RootkitStats {
            total_detections: self.detections.len(),
            critical_detections: self.detections.iter()
                .filter(|d| d.severity == DetectionSeverity::Critical)
                .count(),
            high_detections: self.detections.iter()
                .filter(|d| d.severity == DetectionSeverity::High)
                .count(),
            kernel_modules_loaded: self.kernel_modules.len(),
            suspicious_drivers: self.suspicious_drivers.len(),
            baseline_created: self.baseline.created_at > 0,
        }
    }

    /// Get all detections
    pub fn get_detections(&self) -> Vec<RootkitDetection> {
        self.detections.clone()
    }
}

/// Rootkit detection statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RootkitStats {
    pub total_detections: usize,
    pub critical_detections: usize,
    pub high_detections: usize,
    pub kernel_modules_loaded: usize,
    pub suspicious_drivers: usize,
    pub baseline_created: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rootkit_detector() {
        let config = RootkitDetectorConfig {
            baseline_on_startup: false, // Disable for test
            ..Default::default()
        };

        let detector = RootKitDetector::new(config);
        assert!(detector.is_ok());
    }
}
