/*!
 * Quarantine System
 *
 * Safely isolates detected malware:
 * - Moves malicious files to secure quarantine directory
 * - Encrypts files to prevent execution
 * - Maintains quarantine metadata (original path, detection info)
 * - Allows restore/delete operations
 * - Automatic cleanup of old quarantined files
 */

use std::path::{Path, PathBuf};
use std::fs;
use std::io::{Read, Write};
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce, Key,
};
use rand::Rng;

use crate::malware::scanner::ScanResult;

/// Quarantine configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuarantineConfig {
    /// Quarantine directory
    pub quarantine_dir: PathBuf,

    /// Encryption key (base64)
    pub encryption_key: String,

    /// Auto-delete after days (0 = never)
    pub auto_delete_days: u32,

    /// Maximum quarantine size (bytes)
    pub max_size: u64,
}

impl Default for QuarantineConfig {
    fn default() -> Self {
        Self {
            quarantine_dir: PathBuf::from("/var/lib/custos/quarantine"),
            encryption_key: String::new(), // Generated on first use
            auto_delete_days: 30,
            max_size: 10 * 1024 * 1024 * 1024, // 10GB
        }
    }
}

/// Quarantined file metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuarantinedFile {
    /// Unique quarantine ID
    pub id: String,

    /// Original file path
    pub original_path: PathBuf,

    /// Quarantined file path (encrypted)
    pub quarantine_path: PathBuf,

    /// When quarantined
    pub quarantine_time: DateTime<Utc>,

    /// Scan result that triggered quarantine
    pub scan_result: ScanResult,

    /// File owner
    pub owner: Option<String>,

    /// File permissions
    pub permissions: Option<String>,

    /// Can be restored
    pub can_restore: bool,
}

/// Quarantine system
pub struct QuarantineSystem {
    config: QuarantineConfig,
    cipher: Aes256Gcm,
}

impl QuarantineSystem {
    /// Create new quarantine system
    pub fn new(config: QuarantineConfig) -> Result<Self, String> {
        // Create quarantine directory
        fs::create_dir_all(&config.quarantine_dir)
            .map_err(|e| format!("Failed to create quarantine directory: {}", e))?;

        // Load or generate encryption key
        let key = if config.encryption_key.is_empty() {
            Self::generate_key()
        } else {
            Self::decode_key(&config.encryption_key)?
        };

        let cipher = Aes256Gcm::new(&key);

        Ok(Self { config, cipher })
    }

    /// Quarantine a file
    pub fn quarantine_file(
        &self,
        file_path: &Path,
        scan_result: ScanResult,
    ) -> Result<QuarantinedFile, String> {
        log::info!("Quarantining file: {:?}", file_path);

        // Check if file exists
        if !file_path.exists() {
            return Err(format!("File not found: {:?}", file_path));
        }

        // Generate quarantine ID
        let id = self.generate_id();

        // Read original file
        let original_data = fs::read(file_path)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        // Encrypt data
        let encrypted_data = self.encrypt_data(&original_data)?;

        // Create quarantine path
        let quarantine_path = self.config.quarantine_dir.join(&id);

        // Write encrypted data
        fs::write(&quarantine_path, &encrypted_data)
            .map_err(|e| format!("Failed to write quarantine file: {}", e))?;

        // Get file metadata
        let metadata = fs::metadata(file_path).ok();
        let owner = None; // TODO: Get actual owner
        let permissions = metadata.map(|m| format!("{:?}", m.permissions()));

        // Create quarantine metadata
        let quarantined = QuarantinedFile {
            id: id.clone(),
            original_path: file_path.to_path_buf(),
            quarantine_path: quarantine_path.clone(),
            quarantine_time: Utc::now(),
            scan_result,
            owner,
            permissions,
            can_restore: true,
        };

        // Save metadata
        self.save_metadata(&quarantined)?;

        // Delete original file
        if let Err(e) = fs::remove_file(file_path) {
            log::error!("Failed to delete original file: {}", e);
            // Don't fail the quarantine if we can't delete original
        }

        log::info!("File quarantined: {} -> {:?}", id, quarantine_path);

        Ok(quarantined)
    }

    /// Restore a quarantined file
    pub fn restore_file(&self, id: &str) -> Result<PathBuf, String> {
        log::info!("Restoring quarantined file: {}", id);

        // Load metadata
        let quarantined = self.load_metadata(id)?;

        if !quarantined.can_restore {
            return Err("File cannot be restored".to_string());
        }

        // Read encrypted data
        let encrypted_data = fs::read(&quarantined.quarantine_path)
            .map_err(|e| format!("Failed to read quarantine file: {}", e))?;

        // Decrypt data
        let original_data = self.decrypt_data(&encrypted_data)?;

        // Restore to original location
        fs::write(&quarantined.original_path, &original_data)
            .map_err(|e| format!("Failed to restore file: {}", e))?;

        // Restore permissions
        if let Some(permissions) = quarantined.permissions {
            // TODO: Restore actual permissions
        }

        // Delete quarantine file
        fs::remove_file(&quarantined.quarantine_path)
            .map_err(|e| format!("Failed to delete quarantine file: {}", e))?;

        // Delete metadata
        self.delete_metadata(id)?;

        log::info!("File restored: {:?}", quarantined.original_path);

        Ok(quarantined.original_path)
    }

    /// Delete a quarantined file permanently
    pub fn delete_file(&self, id: &str) -> Result<(), String> {
        log::info!("Deleting quarantined file: {}", id);

        // Load metadata
        let quarantined = self.load_metadata(id)?;

        // Delete quarantine file
        fs::remove_file(&quarantined.quarantine_path)
            .map_err(|e| format!("Failed to delete quarantine file: {}", e))?;

        // Delete metadata
        self.delete_metadata(id)?;

        log::info!("Quarantined file deleted: {}", id);

        Ok(())
    }

    /// List all quarantined files
    pub fn list_quarantined(&self) -> Result<Vec<QuarantinedFile>, String> {
        let mut files = Vec::new();

        let metadata_dir = self.config.quarantine_dir.join("metadata");

        if !metadata_dir.exists() {
            return Ok(files);
        }

        let entries = fs::read_dir(metadata_dir)
            .map_err(|e| format!("Failed to read quarantine directory: {}", e))?;

        for entry in entries {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.extension().and_then(|s| s.to_str()) == Some("json") {
                    if let Ok(metadata) = self.load_metadata_from_path(&path) {
                        files.push(metadata);
                    }
                }
            }
        }

        Ok(files)
    }

    /// Get quarantine statistics
    pub fn get_stats(&self) -> Result<QuarantineStats, String> {
        let files = self.list_quarantined()?;

        let total_count = files.len();
        let mut total_size = 0u64;

        for file in &files {
            if let Ok(metadata) = fs::metadata(&file.quarantine_path) {
                total_size += metadata.len();
            }
        }

        Ok(QuarantineStats {
            total_count,
            total_size,
            max_size: self.config.max_size,
            oldest_file: files.iter().map(|f| f.quarantine_time).min(),
        })
    }

    /// Cleanup old quarantined files
    pub fn cleanup_old_files(&self) -> Result<usize, String> {
        if self.config.auto_delete_days == 0 {
            return Ok(0);
        }

        let files = self.list_quarantined()?;
        let cutoff = Utc::now() - chrono::Duration::days(self.config.auto_delete_days as i64);

        let mut deleted = 0;

        for file in files {
            if file.quarantine_time < cutoff {
                if let Err(e) = self.delete_file(&file.id) {
                    log::error!("Failed to cleanup old file {}: {}", file.id, e);
                } else {
                    deleted += 1;
                }
            }
        }

        if deleted > 0 {
            log::info!("Cleaned up {} old quarantined files", deleted);
        }

        Ok(deleted)
    }

    /// Encrypt data
    fn encrypt_data(&self, data: &[u8]) -> Result<Vec<u8>, String> {
        let mut rng = rand::thread_rng();
        let nonce_bytes: [u8; 12] = rng.gen();
        let nonce = Nonce::from_slice(&nonce_bytes);

        let encrypted = self.cipher
            .encrypt(nonce, data)
            .map_err(|e| format!("Encryption failed: {}", e))?;

        // Prepend nonce to encrypted data
        let mut result = Vec::with_capacity(12 + encrypted.len());
        result.extend_from_slice(&nonce_bytes);
        result.extend_from_slice(&encrypted);

        Ok(result)
    }

    /// Decrypt data
    fn decrypt_data(&self, data: &[u8]) -> Result<Vec<u8>, String> {
        if data.len() < 12 {
            return Err("Invalid encrypted data".to_string());
        }

        // Extract nonce (first 12 bytes)
        let nonce = Nonce::from_slice(&data[0..12]);

        // Decrypt remaining data
        let encrypted = &data[12..];

        let decrypted = self.cipher
            .decrypt(nonce, encrypted)
            .map_err(|e| format!("Decryption failed: {}", e))?;

        Ok(decrypted)
    }

    /// Generate unique quarantine ID
    fn generate_id(&self) -> String {
        use sha2::{Sha256, Digest};

        let timestamp = Utc::now().timestamp_nanos();
        let random: u64 = rand::thread_rng().gen();
        let data = format!("{}{}", timestamp, random);

        let mut hasher = Sha256::new();
        hasher.update(data.as_bytes());
        let result = hasher.finalize();

        format!("{:x}", result)
    }

    /// Generate encryption key
    fn generate_key() -> Key<Aes256Gcm> {
        Aes256Gcm::generate_key(&mut OsRng)
    }

    /// Decode base64 encryption key
    fn decode_key(encoded: &str) -> Result<Key<Aes256Gcm>, String> {
        use base64::{Engine as _, engine::general_purpose};

        let decoded = general_purpose::STANDARD
            .decode(encoded)
            .map_err(|e| format!("Invalid encryption key: {}", e))?;

        if decoded.len() != 32 {
            return Err("Invalid key length".to_string());
        }

        Ok(*Key::<Aes256Gcm>::from_slice(&decoded))
    }

    /// Save quarantine metadata
    fn save_metadata(&self, quarantined: &QuarantinedFile) -> Result<(), String> {
        let metadata_dir = self.config.quarantine_dir.join("metadata");
        fs::create_dir_all(&metadata_dir)
            .map_err(|e| format!("Failed to create metadata directory: {}", e))?;

        let metadata_path = metadata_dir.join(format!("{}.json", quarantined.id));

        let json = serde_json::to_string_pretty(quarantined)
            .map_err(|e| format!("Failed to serialize metadata: {}", e))?;

        fs::write(&metadata_path, json)
            .map_err(|e| format!("Failed to write metadata: {}", e))?;

        Ok(())
    }

    /// Load quarantine metadata
    fn load_metadata(&self, id: &str) -> Result<QuarantinedFile, String> {
        let metadata_path = self.config.quarantine_dir
            .join("metadata")
            .join(format!("{}.json", id));

        self.load_metadata_from_path(&metadata_path)
    }

    /// Load metadata from path
    fn load_metadata_from_path(&self, path: &Path) -> Result<QuarantinedFile, String> {
        let json = fs::read_to_string(path)
            .map_err(|e| format!("Failed to read metadata: {}", e))?;

        serde_json::from_str(&json)
            .map_err(|e| format!("Failed to parse metadata: {}", e))
    }

    /// Delete quarantine metadata
    fn delete_metadata(&self, id: &str) -> Result<(), String> {
        let metadata_path = self.config.quarantine_dir
            .join("metadata")
            .join(format!("{}.json", id));

        fs::remove_file(&metadata_path)
            .map_err(|e| format!("Failed to delete metadata: {}", e))?;

        Ok(())
    }
}

/// Quarantine statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct QuarantineStats {
    pub total_count: usize,
    pub total_size: u64,
    pub max_size: u64,
    pub oldest_file: Option<DateTime<Utc>>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::TempDir;

    #[test]
    fn test_quarantine_system() {
        let temp_dir = TempDir::new().unwrap();
        let quarantine_dir = temp_dir.path().join("quarantine");

        let config = QuarantineConfig {
            quarantine_dir: quarantine_dir.clone(),
            ..Default::default()
        };

        let system = QuarantineSystem::new(config).unwrap();

        // Create test file
        let test_file = temp_dir.path().join("malware.exe");
        let mut file = fs::File::create(&test_file).unwrap();
        file.write_all(b"malicious content").unwrap();

        // Create fake scan result
        let scan_result = crate::malware::scanner::ScanResult {
            is_malicious: true,
            threat_name: Some("Test Malware".to_string()),
            detection_method: crate::malware::scanner::DetectionMethod::Hash,
            confidence: 1.0,
            file_hash: "test_hash".to_string(),
            file_size: 17,
            scan_duration_ms: 10,
            details: crate::malware::scanner::ScanDetails {
                hash_malicious: true,
                yara_matches: vec![],
                ml_prediction: None,
                suspicious_indicators: vec![],
                file_type: None,
                packer_detected: None,
            },
        };

        // Quarantine file
        let quarantined = system.quarantine_file(&test_file, scan_result).unwrap();

        // Original file should be deleted
        assert!(!test_file.exists());

        // Quarantine file should exist
        assert!(quarantined.quarantine_path.exists());

        // List quarantined files
        let files = system.list_quarantined().unwrap();
        assert_eq!(files.len(), 1);

        // Restore file
        let restored_path = system.restore_file(&quarantined.id).unwrap();
        assert!(restored_path.exists());

        // Quarantine file should be deleted
        assert!(!quarantined.quarantine_path.exists());
    }

    #[test]
    fn test_encryption() {
        let config = QuarantineConfig::default();
        let system = QuarantineSystem::new(config).unwrap();

        let original_data = b"sensitive malware data";

        // Encrypt
        let encrypted = system.encrypt_data(original_data).unwrap();
        assert_ne!(&encrypted[12..], original_data); // Should be different

        // Decrypt
        let decrypted = system.decrypt_data(&encrypted).unwrap();
        assert_eq!(decrypted, original_data);
    }
}
