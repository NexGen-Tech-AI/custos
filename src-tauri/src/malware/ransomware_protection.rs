/*!
 * Ransomware Protection Engine
 *
 * Multi-layered ransomware defense system:
 * - Decoy file honeypots that trigger instant alerts
 * - Rapid encryption detection via I/O pattern analysis
 * - Automatic backup and recovery system
 * - Behavior-based ransomware detection
 * - Kill chain interruption before encryption
 */

use std::collections::{HashMap, HashSet, VecDeque};
use std::path::{Path, PathBuf};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};

/// Ransomware protection engine
pub struct RansomwareProtectionEngine {
    decoy_files: Vec<DecoyFile>,
    monitored_processes: HashMap<u32, ProcessActivity>,
    encryption_alerts: Vec<EncryptionAlert>,
    backups: Vec<FileBackup>,
    config: RansomwareConfig,
    protected_dirs: HashSet<PathBuf>,
    activity_buffer: VecDeque<FileActivity>,
}

/// Ransomware protection configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RansomwareConfig {
    pub enabled: bool,
    pub use_decoys: bool,
    pub auto_backup: bool,
    pub auto_terminate: bool,
    pub encryption_threshold: f64,
    pub activity_window_secs: u64,
    pub max_files_per_second: usize,
    pub entropy_threshold: f64,
    pub protected_extensions: Vec<String>,
}

impl Default for RansomwareConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            use_decoys: true,
            auto_backup: true,
            auto_terminate: true,
            encryption_threshold: 0.75,
            activity_window_secs: 5,
            max_files_per_second: 10,
            entropy_threshold: 7.5,
            protected_extensions: vec![
                "doc".to_string(), "docx".to_string(), "pdf".to_string(),
                "xls".to_string(), "xlsx".to_string(), "ppt".to_string(),
                "jpg".to_string(), "png".to_string(), "mp4".to_string(),
                "zip".to_string(), "sql".to_string(), "db".to_string(),
            ],
        }
    }
}

/// Decoy file (honeypot)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecoyFile {
    pub path: PathBuf,
    pub created: i64,
    pub accessed: Option<i64>,
    pub modified: Option<i64>,
    pub decoy_type: DecoyType,
    pub triggered: bool,
}

/// Type of decoy file
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DecoyType {
    Document,      // Fake .docx, .pdf
    Spreadsheet,   // Fake .xlsx
    Image,         // Fake .jpg
    Database,      // Fake .db
    Backup,        // Fake .bak
}

/// File activity record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileActivity {
    pub timestamp: i64,
    pub process_id: u32,
    pub process_name: String,
    pub file_path: PathBuf,
    pub operation: FileOperation,
    pub entropy_delta: Option<f64>,
}

/// File operation type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum FileOperation {
    Read,
    Write,
    Delete,
    Rename,
    Encrypt, // Detected encryption
}

/// Process activity tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessActivity {
    pub process_id: u32,
    pub process_name: String,
    pub start_time: i64,
    pub files_modified: usize,
    pub files_deleted: usize,
    pub files_renamed: usize,
    pub suspicious_extensions: HashSet<String>,
    pub encryption_score: f64,
    pub decoy_triggered: bool,
}

/// Encryption detection alert
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptionAlert {
    pub id: String,
    pub timestamp: i64,
    pub process_id: u32,
    pub process_name: String,
    pub detected_files: Vec<PathBuf>,
    pub encryption_score: f64,
    pub severity: AlertSeverity,
    pub action_taken: Option<ResponseAction>,
}

/// Alert severity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]
pub enum AlertSeverity {
    Critical,  // Active ransomware detected
    High,      // Likely ransomware behavior
    Medium,    // Suspicious encryption activity
    Low,       // Unusual file operations
}

/// Response action taken
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ResponseAction {
    ProcessTerminated,
    FilesRestored { count: usize },
    SystemIsolated,
    BackupCreated { path: PathBuf },
    AlertSent,
}

/// File backup
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileBackup {
    pub original_path: PathBuf,
    pub backup_path: PathBuf,
    pub backup_time: i64,
    pub file_hash: String,
    pub size: u64,
}

/// Ransomware detection result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RansomwareDetection {
    pub detected: bool,
    pub confidence: f64,
    pub process_id: u32,
    pub process_name: String,
    pub indicators: Vec<RansomwareIndicator>,
    pub affected_files: Vec<PathBuf>,
}

/// Ransomware indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RansomwareIndicator {
    DecoyFileAccessed { path: PathBuf },
    RapidEncryption { files_per_sec: f64 },
    MassFileDeletion { count: usize },
    SuspiciousRenames { patterns: Vec<String> },
    HighEntropy { average: f64 },
    DropperBehavior { note_file: PathBuf },
    NetworkBeacon { c2_address: String },
}

impl RansomwareProtectionEngine {
    /// Create new ransomware protection engine
    pub fn new(config: RansomwareConfig) -> Result<Self, String> {
        log::info!("ðŸ›¡ï¸  Initializing ransomware protection engine");

        let mut engine = Self {
            decoy_files: Vec::new(),
            monitored_processes: HashMap::new(),
            encryption_alerts: Vec::new(),
            backups: Vec::new(),
            config: config.clone(),
            protected_dirs: HashSet::new(),
            activity_buffer: VecDeque::new(),
        };

        // Add default protected directories
        if let Ok(home_dir) = std::env::var("HOME") {
            let home_path = PathBuf::from(home_dir);
            let _ = engine.add_protected_directory(home_path.join("Documents"));
            let _ = engine.add_protected_directory(home_path.join("Pictures"));
            let _ = engine.add_protected_directory(home_path.join("Desktop"));
        }

        // Deploy decoy files if enabled
        if config.use_decoys {
            engine.deploy_decoys()?;
        }

        log::info!("âœ… Ransomware protection engine initialized");
        Ok(engine)
    }

    /// Add a directory to protect
    pub fn add_protected_directory(&mut self, path: PathBuf) -> Result<(), String> {
        if !path.exists() {
            return Err(format!("Directory does not exist: {:?}", path));
        }

        self.protected_dirs.insert(path.clone());
        log::info!("ðŸ”’ Added protected directory: {:?}", path);
        Ok(())
    }

    /// Deploy decoy files in protected directories
    pub fn deploy_decoys(&mut self) -> Result<usize, String> {
        log::info!("ðŸ¯ Deploying decoy files (honeypots)");

        let decoy_configs = vec![
            ("IMPORTANT_BACKUP.docx", DecoyType::Document),
            ("Financial_Report_2024.xlsx", DecoyType::Spreadsheet),
            ("Family_Photos_Archive.jpg", DecoyType::Image),
            ("Passwords.db", DecoyType::Database),
            ("System_Backup.bak", DecoyType::Backup),
        ];

        let mut deployed = 0;

        for protected_dir in &self.protected_dirs.clone() {
            for (filename, decoy_type) in &decoy_configs {
                let decoy_path = protected_dir.join(filename);

                // Create decoy file with honeypot content
                if let Err(e) = std::fs::write(&decoy_path, self.generate_decoy_content(decoy_type)) {
                    log::warn!("Failed to create decoy file {:?}: {}", decoy_path, e);
                    continue;
                }

                // Hide file on Windows (set hidden attribute)
                #[cfg(windows)]
                {
                    use std::os::windows::fs::MetadataExt;
                    // Set hidden attribute - implementation omitted for brevity
                }

                let decoy = DecoyFile {
                    path: decoy_path.clone(),
                    created: Self::current_timestamp(),
                    accessed: None,
                    modified: None,
                    decoy_type: decoy_type.clone(),
                    triggered: false,
                };

                self.decoy_files.push(decoy);
                deployed += 1;

                log::debug!("ðŸ¯ Deployed decoy: {:?}", decoy_path);
            }
        }

        log::info!("âœ… Deployed {} decoy files", deployed);
        Ok(deployed)
    }

    /// Generate decoy file content
    fn generate_decoy_content(&self, decoy_type: &DecoyType) -> Vec<u8> {
        match decoy_type {
            DecoyType::Document => {
                // Minimal valid DOCX header
                b"PK\x03\x04DECOY_DOCUMENT_HONEYPOT".to_vec()
            }
            DecoyType::Spreadsheet => {
                // Minimal valid XLSX header
                b"PK\x03\x04DECOY_SPREADSHEET_HONEYPOT".to_vec()
            }
            DecoyType::Image => {
                // Minimal valid JPEG header
                let mut content = vec![0xFF, 0xD8, 0xFF, 0xE0];
                content.extend_from_slice(b"DECOY_IMAGE_HONEYPOT");
                content
            }
            DecoyType::Database => {
                b"SQLite format 3\x00DECOY_DATABASE_HONEYPOT".to_vec()
            }
            DecoyType::Backup => {
                b"BACKUP_FILE_HONEYPOT_DO_NOT_ENCRYPT".to_vec()
            }
        }
    }

    /// Check if a file is a decoy
    pub fn is_decoy(&self, path: &Path) -> bool {
        self.decoy_files.iter().any(|d| d.path == path)
    }

    /// Record file activity
    pub fn record_activity(&mut self, activity: FileActivity) -> Result<(), String> {
        // Check if decoy file was accessed
        if self.is_decoy(&activity.file_path) {
            self.handle_decoy_trigger(&activity)?;
        }

        // Add to activity buffer
        self.activity_buffer.push_back(activity.clone());

        // Clean old activities outside the window
        let cutoff = Self::current_timestamp() - self.config.activity_window_secs as i64;
        while let Some(front) = self.activity_buffer.front() {
            if front.timestamp < cutoff {
                self.activity_buffer.pop_front();
            } else {
                break;
            }
        }

        // Update process activity tracking
        let process_activity = self.monitored_processes
            .entry(activity.process_id)
            .or_insert_with(|| ProcessActivity {
                process_id: activity.process_id,
                process_name: activity.process_name.clone(),
                start_time: Self::current_timestamp(),
                files_modified: 0,
                files_deleted: 0,
                files_renamed: 0,
                suspicious_extensions: HashSet::new(),
                encryption_score: 0.0,
                decoy_triggered: false,
            });

        match activity.operation {
            FileOperation::Write | FileOperation::Encrypt => {
                process_activity.files_modified += 1;
            }
            FileOperation::Delete => {
                process_activity.files_deleted += 1;
            }
            FileOperation::Rename => {
                process_activity.files_renamed += 1;
            }
            _ => {}
        }

        // Track suspicious file extensions
        if let Some(ext) = activity.file_path.extension() {
            if let Some(ext_str) = ext.to_str() {
                if !self.config.protected_extensions.contains(&ext_str.to_string()) {
                    process_activity.suspicious_extensions.insert(ext_str.to_string());
                }
            }
        }

        // Analyze for ransomware behavior
        let detection = self.analyze_ransomware_behavior(activity.process_id)?;
        if detection.detected && detection.confidence >= self.config.encryption_threshold {
            self.handle_ransomware_detection(detection)?;
        }

        Ok(())
    }

    /// Handle decoy file trigger
    fn handle_decoy_trigger(&mut self, activity: &FileActivity) -> Result<(), String> {
        log::error!(
            "ðŸš¨ RANSOMWARE ALERT: Decoy file accessed by PID {} ({})",
            activity.process_id, activity.process_name
        );

        // Mark decoy as triggered
        for decoy in &mut self.decoy_files {
            if decoy.path == activity.file_path {
                decoy.triggered = true;
                decoy.accessed = Some(Self::current_timestamp());
            }
        }

        // Mark process as ransomware
        if let Some(process_activity) = self.monitored_processes.get_mut(&activity.process_id) {
            process_activity.decoy_triggered = true;
            process_activity.encryption_score = 1.0; // Maximum score
        }

        // Create critical alert
        let alert = EncryptionAlert {
            id: format!("DECOY-{}-{}", activity.process_id, Self::current_timestamp()),
            timestamp: Self::current_timestamp(),
            process_id: activity.process_id,
            process_name: activity.process_name.clone(),
            detected_files: vec![activity.file_path.clone()],
            encryption_score: 1.0,
            severity: AlertSeverity::Critical,
            action_taken: None,
        };

        self.encryption_alerts.push(alert);

        // Auto-terminate if enabled
        if self.config.auto_terminate {
            self.terminate_process(activity.process_id)?;
        }

        Ok(())
    }

    /// Analyze process for ransomware behavior
    pub fn analyze_ransomware_behavior(&self, process_id: u32) -> Result<RansomwareDetection, String> {
        let process_activity = self.monitored_processes.get(&process_id)
            .ok_or_else(|| format!("Process {} not found", process_id))?;

        let mut indicators = Vec::new();
        let mut confidence = 0.0;

        // Indicator 1: Decoy file accessed (100% confidence)
        if process_activity.decoy_triggered {
            indicators.push(RansomwareIndicator::DecoyFileAccessed {
                path: PathBuf::from("decoy"),
            });
            confidence = 1.0;

            return Ok(RansomwareDetection {
                detected: true,
                confidence,
                process_id,
                process_name: process_activity.process_name.clone(),
                indicators,
                affected_files: Vec::new(),
            });
        }

        // Indicator 2: Rapid file modifications (high confidence)
        let elapsed = Self::current_timestamp() - process_activity.start_time;
        let elapsed_secs = elapsed.max(1) as f64;
        let files_per_sec = process_activity.files_modified as f64 / elapsed_secs;

        if files_per_sec > self.config.max_files_per_second as f64 {
            indicators.push(RansomwareIndicator::RapidEncryption { files_per_sec });
            confidence += 0.4;
        }

        // Indicator 3: Mass file deletions
        if process_activity.files_deleted > 20 {
            indicators.push(RansomwareIndicator::MassFileDeletion {
                count: process_activity.files_deleted,
            });
            confidence += 0.3;
        }

        // Indicator 4: Suspicious file renames (e.g., adding .encrypted extension)
        if process_activity.files_renamed > 10 {
            let patterns: Vec<String> = process_activity.suspicious_extensions
                .iter()
                .cloned()
                .collect();

            if !patterns.is_empty() {
                indicators.push(RansomwareIndicator::SuspiciousRenames { patterns });
                confidence += 0.3;
            }
        }

        // Indicator 5: High entropy changes (encryption detection)
        let avg_entropy = self.calculate_average_entropy(process_id);
        if avg_entropy > self.config.entropy_threshold {
            indicators.push(RansomwareIndicator::HighEntropy { average: avg_entropy });
            confidence += 0.4;
        }

        // Normalize confidence to 0.0-1.0
        confidence = confidence.min(1.0);

        let detected = confidence >= self.config.encryption_threshold;

        if detected {
            log::warn!(
                "âš ï¸  Ransomware behavior detected in PID {} ({}): confidence {:.2}%",
                process_id, process_activity.process_name, confidence * 100.0
            );
        }

        Ok(RansomwareDetection {
            detected,
            confidence,
            process_id,
            process_name: process_activity.process_name.clone(),
            indicators,
            affected_files: Vec::new(),
        })
    }

    /// Calculate average entropy for process activities
    fn calculate_average_entropy(&self, process_id: u32) -> f64 {
        let activities: Vec<&FileActivity> = self.activity_buffer
            .iter()
            .filter(|a| a.process_id == process_id && a.entropy_delta.is_some())
            .collect();

        if activities.is_empty() {
            return 0.0;
        }

        let sum: f64 = activities.iter()
            .filter_map(|a| a.entropy_delta)
            .sum();

        sum / activities.len() as f64
    }

    /// Handle ransomware detection
    fn handle_ransomware_detection(&mut self, detection: RansomwareDetection) -> Result<(), String> {
        log::error!(
            "ðŸš¨ RANSOMWARE DETECTED: PID {} ({}) - Confidence: {:.1}%",
            detection.process_id, detection.process_name, detection.confidence * 100.0
        );

        let mut actions = Vec::new();

        // Terminate malicious process
        if self.config.auto_terminate {
            if let Ok(_) = self.terminate_process(detection.process_id) {
                actions.push(ResponseAction::ProcessTerminated);
            }
        }

        // Restore encrypted files from backup
        if self.config.auto_backup {
            let restored = self.restore_recent_backups()?;
            if restored > 0 {
                actions.push(ResponseAction::FilesRestored { count: restored });
            }
        }

        // Create alert
        let alert = EncryptionAlert {
            id: format!("RW-{}-{}", detection.process_id, Self::current_timestamp()),
            timestamp: Self::current_timestamp(),
            process_id: detection.process_id,
            process_name: detection.process_name.clone(),
            detected_files: detection.affected_files.clone(),
            encryption_score: detection.confidence,
            severity: if detection.confidence > 0.9 {
                AlertSeverity::Critical
            } else if detection.confidence > 0.8 {
                AlertSeverity::High
            } else {
                AlertSeverity::Medium
            },
            action_taken: actions.first().cloned(),
        };

        self.encryption_alerts.push(alert);

        Ok(())
    }

    /// Terminate a process
    fn terminate_process(&self, process_id: u32) -> Result<(), String> {
        log::warn!("ðŸ›‘ Terminating ransomware process: PID {}", process_id);

        #[cfg(target_os = "linux")]
        {
            use std::process::Command;
            Command::new("kill")
                .args(&["-9", &process_id.to_string()])
                .output()
                .map_err(|e| format!("Failed to kill process: {}", e))?;
        }

        #[cfg(target_os = "windows")]
        {
            // Windows implementation
            use std::process::Command;
            Command::new("taskkill")
                .args(&["/F", "/PID", &process_id.to_string()])
                .output()
                .map_err(|e| format!("Failed to kill process: {}", e))?;
        }

        log::info!("âœ… Process {} terminated successfully", process_id);
        Ok(())
    }

    /// Create backup of a file
    pub fn create_backup(&mut self, file_path: &Path) -> Result<FileBackup, String> {
        if !file_path.exists() {
            return Err(format!("File does not exist: {:?}", file_path));
        }

        let backup_dir = PathBuf::from("./data/ransomware_backups");
        std::fs::create_dir_all(&backup_dir)
            .map_err(|e| format!("Failed to create backup directory: {}", e))?;

        let timestamp = Self::current_timestamp();
        let filename = file_path.file_name()
            .ok_or_else(|| "Invalid filename".to_string())?;

        let backup_filename = format!("{}_{}", timestamp, filename.to_string_lossy());
        let backup_path = backup_dir.join(backup_filename);

        // Copy file
        std::fs::copy(file_path, &backup_path)
            .map_err(|e| format!("Failed to copy file: {}", e))?;

        // Calculate hash
        let content = std::fs::read(&backup_path)
            .map_err(|e| format!("Failed to read backup: {}", e))?;
        let hash = format!("{:x}", md5::compute(&content));

        let metadata = std::fs::metadata(&backup_path)
            .map_err(|e| format!("Failed to read metadata: {}", e))?;

        let backup = FileBackup {
            original_path: file_path.to_path_buf(),
            backup_path: backup_path.clone(),
            backup_time: timestamp,
            file_hash: hash,
            size: metadata.len(),
        };

        self.backups.push(backup.clone());

        log::debug!("ðŸ’¾ Created backup: {:?} -> {:?}", file_path, backup_path);
        Ok(backup)
    }

    /// Restore recent backups (last 24 hours)
    fn restore_recent_backups(&self) -> Result<usize, String> {
        let cutoff = Self::current_timestamp() - (24 * 3600);
        let recent_backups: Vec<&FileBackup> = self.backups
            .iter()
            .filter(|b| b.backup_time >= cutoff)
            .collect();

        let mut restored = 0;

        for backup in recent_backups {
            if let Ok(_) = std::fs::copy(&backup.backup_path, &backup.original_path) {
                restored += 1;
                log::info!("â™»ï¸  Restored file from backup: {:?}", backup.original_path);
            }
        }

        Ok(restored)
    }

    /// Get current timestamp
    fn current_timestamp() -> i64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64
    }

    /// Get protection statistics
    pub fn get_stats(&self) -> RansomwareStats {
        RansomwareStats {
            decoys_deployed: self.decoy_files.len(),
            decoys_triggered: self.decoy_files.iter().filter(|d| d.triggered).count(),
            alerts_generated: self.encryption_alerts.len(),
            critical_alerts: self.encryption_alerts.iter()
                .filter(|a| a.severity == AlertSeverity::Critical)
                .count(),
            files_backed_up: self.backups.len(),
            protected_directories: self.protected_dirs.len(),
            monitored_processes: self.monitored_processes.len(),
        }
    }

    /// Get all encryption alerts
    pub fn get_alerts(&self) -> Vec<EncryptionAlert> {
        self.encryption_alerts.clone()
    }
}

/// Ransomware protection statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RansomwareStats {
    pub decoys_deployed: usize,
    pub decoys_triggered: usize,
    pub alerts_generated: usize,
    pub critical_alerts: usize,
    pub files_backed_up: usize,
    pub protected_directories: usize,
    pub monitored_processes: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ransomware_protection() {
        let config = RansomwareConfig {
            use_decoys: false, // Disable for test
            ..Default::default()
        };

        let engine = RansomwareProtectionEngine::new(config);
        assert!(engine.is_ok());
    }

    #[test]
    fn test_decoy_detection() {
        let config = RansomwareConfig {
            use_decoys: false,
            ..Default::default()
        };

        let engine = RansomwareProtectionEngine::new(config).unwrap();
        let fake_path = PathBuf::from("/tmp/not_a_decoy.txt");
        assert!(!engine.is_decoy(&fake_path));
    }
}
