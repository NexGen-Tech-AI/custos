/*!
 * Real-Time File Monitoring System
 *
 * Monitors file system events for potential malware activity:
 * - File creation, modification, execution
 * - Download completion
 * - Executable access
 *
 * Platform-specific implementations:
 * - Linux: inotify + fanotify (with eBPF planned)
 * - Windows: ReadDirectoryChangesW + kernel filter driver (planned)
 * - macOS: FSEvents + Endpoint Security (planned)
 */

use notify::{Watcher, RecursiveMode, Event, EventKind};
use std::path::{Path, PathBuf};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use crossbeam::channel::{Sender, Receiver};
use chrono::Utc;
use serde::{Serialize, Deserialize};

use crate::malware::scanner::FileScanner;

/// File event types that trigger scanning
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FileEventType {
    Created,
    Modified,
    Executed,
    Downloaded,
    Opened,
}

/// File event metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileEvent {
    pub path: PathBuf,
    pub event_type: FileEventType,
    pub timestamp: i64,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub file_size: Option<u64>,
    pub file_hash: Option<String>,
}

/// File monitoring configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitorConfig {
    /// Paths to monitor
    pub watch_paths: Vec<PathBuf>,

    /// Paths to exclude from monitoring
    pub exclude_paths: Vec<PathBuf>,

    /// File extensions to monitor (empty = all)
    pub extensions: Vec<String>,

    /// Scan on file creation
    pub scan_on_create: bool,

    /// Scan on file modification
    pub scan_on_modify: bool,

    /// Scan on file execution
    pub scan_on_execute: bool,

    /// Scan downloads directory
    pub scan_downloads: bool,

    /// Maximum file size to scan (bytes)
    pub max_file_size: u64,
}

impl Default for MonitorConfig {
    fn default() -> Self {
        Self {
            watch_paths: vec![
                PathBuf::from("/home"),      // Linux home directories
                PathBuf::from("/tmp"),        // Temp directory
                PathBuf::from("/var/tmp"),    // Var temp
            ],
            exclude_paths: vec![
                PathBuf::from("/home/.cache"),
                PathBuf::from("/tmp/.X11-unix"),
            ],
            extensions: vec![
                "exe".to_string(), "dll".to_string(), "so".to_string(),
                "sh".to_string(), "py".to_string(), "js".to_string(),
                "elf".to_string(), "bin".to_string(), "app".to_string(),
            ],
            scan_on_create: true,
            scan_on_modify: true,
            scan_on_execute: true,
            scan_downloads: true,
            max_file_size: 500 * 1024 * 1024, // 500MB
        }
    }
}

/// File monitor state
pub struct FileMonitor {
    config: MonitorConfig,
    watcher: Option<notify::RecommendedWatcher>,
    event_tx: Sender<FileEvent>,
    event_rx: Receiver<FileEvent>,
    scanner: Arc<Mutex<FileScanner>>,
    active_scans: Arc<Mutex<HashMap<PathBuf, bool>>>,
}

impl FileMonitor {
    /// Create new file monitor
    pub fn new(config: MonitorConfig, scanner: Arc<Mutex<FileScanner>>) -> Result<Self, String> {
        let (event_tx, event_rx) = crossbeam::channel::unbounded();

        Ok(Self {
            config,
            watcher: None,
            event_tx,
            event_rx,
            scanner,
            active_scans: Arc::new(Mutex::new(HashMap::new())),
        })
    }

    /// Start monitoring file system
    pub fn start(&mut self) -> Result<(), String> {
        log::info!("Starting file system monitor");

        // Create watcher
        let tx = self.event_tx.clone();
        let config = self.config.clone();

        let mut watcher = notify::recommended_watcher(move |res: Result<Event, notify::Error>| {
            match res {
                Ok(event) => {
                    if let Err(e) = Self::handle_notify_event(event, &tx, &config) {
                        log::error!("Error handling file event: {}", e);
                    }
                }
                Err(e) => log::error!("Watch error: {:?}", e),
            }
        }).map_err(|e| format!("Failed to create watcher: {}", e))?;

        // Watch configured paths
        for path in &self.config.watch_paths {
            if path.exists() {
                watcher.watch(path, RecursiveMode::Recursive)
                    .map_err(|e| format!("Failed to watch {:?}: {}", path, e))?;
                log::info!("Watching path: {:?}", path);
            } else {
                log::warn!("Path does not exist: {:?}", path);
            }
        }

        self.watcher = Some(watcher);

        // Start event processing thread
        self.start_event_processor();

        log::info!("File system monitor started");

        Ok(())
    }

    /// Stop monitoring
    pub fn stop(&mut self) {
        log::info!("Stopping file system monitor");
        self.watcher = None;
    }

    /// Handle notify event and convert to FileEvent
    fn handle_notify_event(
        event: Event,
        tx: &Sender<FileEvent>,
        config: &MonitorConfig,
    ) -> Result<(), String> {
        // Filter by event kind
        let event_type = match event.kind {
            EventKind::Create(_) => {
                if !config.scan_on_create {
                    return Ok(());
                }
                FileEventType::Created
            }
            EventKind::Modify(_) => {
                if !config.scan_on_modify {
                    return Ok(());
                }
                FileEventType::Modified
            }
            EventKind::Access(_) => {
                if !config.scan_on_execute {
                    return Ok(());
                }
                FileEventType::Opened
            }
            _ => return Ok(()), // Ignore other events
        };

        // Process each path in the event
        for path in event.paths {
            // Check if path should be excluded
            if Self::should_exclude(&path, config) {
                continue;
            }

            // Check file extension
            if !config.extensions.is_empty() {
                if let Some(ext) = path.extension() {
                    let ext_str = ext.to_string_lossy().to_lowercase();
                    if !config.extensions.contains(&ext_str) {
                        continue;
                    }
                } else {
                    continue; // No extension
                }
            }

            // Check file size
            if let Ok(metadata) = std::fs::metadata(&path) {
                if metadata.len() > config.max_file_size {
                    log::debug!("Skipping large file: {:?} ({}MB)", path, metadata.len() / 1024 / 1024);
                    continue;
                }
            }

            // Create file event
            let file_event = FileEvent {
                path: path.clone(),
                event_type: event_type.clone(),
                timestamp: Utc::now().timestamp(),
                process_name: None, // TODO: Get process info
                process_pid: None,
                file_size: None,
                file_hash: None,
            };

            // Send event for processing
            if let Err(e) = tx.send(file_event) {
                log::error!("Failed to send file event: {}", e);
            }
        }

        Ok(())
    }

    /// Check if path should be excluded
    fn should_exclude(path: &Path, config: &MonitorConfig) -> bool {
        for exclude in &config.exclude_paths {
            if path.starts_with(exclude) {
                return true;
            }
        }
        false
    }

    /// Start event processing thread
    fn start_event_processor(&self) {
        let rx = self.event_rx.clone();
        let scanner = self.scanner.clone();
        let active_scans = self.active_scans.clone();

        std::thread::spawn(move || {
            log::info!("File event processor started");

            while let Ok(event) = rx.recv() {
                // Check if already scanning this file
                {
                    let mut scans = active_scans.lock().unwrap();
                    if scans.contains_key(&event.path) {
                        log::debug!("Scan already in progress: {:?}", event.path);
                        continue;
                    }
                    scans.insert(event.path.clone(), true);
                }

                log::debug!("Processing file event: {:?} ({:?})", event.path, event.event_type);

                // Scan file
                let path = event.path.clone();
                let scanner_clone = scanner.clone();

                std::thread::spawn(move || {
                    let result = {
                        let scanner = scanner_clone.lock().unwrap();
                        scanner.scan_file(&path)
                    };

                    match result {
                        Ok(scan_result) => {
                            if scan_result.is_malicious {
                                log::warn!(
                                    "âš ï¸  MALWARE DETECTED: {:?} (threat: {}, confidence: {:.1}%)",
                                    path,
                                    scan_result.threat_name.unwrap_or_else(|| "Unknown".to_string()),
                                    scan_result.confidence * 100.0
                                );

                                // TODO: Quarantine file
                                // TODO: Alert user
                            } else {
                                log::debug!("âœ… File clean: {:?}", path);
                            }
                        }
                        Err(e) => {
                            log::error!("Failed to scan file {:?}: {}", path, e);
                        }
                    }
                });

                // Remove from active scans
                {
                    let mut scans = active_scans.lock().unwrap();
                    scans.remove(&event.path);
                }
            }

            log::info!("File event processor stopped");
        });
    }

    /// Get monitoring statistics
    pub fn get_stats(&self) -> MonitorStats {
        let active_scans = self.active_scans.lock().unwrap();

        MonitorStats {
            watching_paths: self.config.watch_paths.len(),
            active_scans: active_scans.len(),
            total_events: 0, // TODO: Track this
        }
    }
}

/// Monitoring statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct MonitorStats {
    pub watching_paths: usize,
    pub active_scans: usize,
    pub total_events: u64,
}

#[cfg(target_os = "linux")]
pub mod linux {
    //! Linux-specific file monitoring using fanotify
    //!
    //! Fanotify provides:
    //! - Pre-access notification (block before execution)
    //! - File descriptor access
    //! - Better performance than inotify
    //!
    //! Requires:
    //! - CAP_SYS_ADMIN capability
    //! - Kernel 5.1+ for FAN_OPEN_EXEC_PERM

    use std::path::{Path, PathBuf};
    use std::os::unix::io::{AsRawFd, RawFd};
    use std::fs::File;
    use std::io::Read;
    use std::sync::{Arc, Mutex};
    use std::collections::HashSet;
    use std::thread;
    use std::time::Duration;
    use libc::{self, c_int, c_uint};
    use serde::{Serialize, Deserialize};

    use crate::malware::scanner::FileScanner;

    // Fanotify constants (from linux/fanotify.h)
    const FAN_CLASS_CONTENT: c_uint = 0x00000004;
    const FAN_CLASS_PRE_CONTENT: c_uint = 0x00000008;
    const FAN_CLOEXEC: c_uint = 0x00000001;
    const FAN_NONBLOCK: c_uint = 0x00000002;
    const FAN_UNLIMITED_QUEUE: c_uint = 0x00000010;
    const FAN_UNLIMITED_MARKS: c_uint = 0x00000020;

    // Event flags
    const FAN_OPEN: u64 = 0x00000020;
    const FAN_OPEN_EXEC: u64 = 0x00001000;
    const FAN_OPEN_EXEC_PERM: u64 = 0x00040000;
    const FAN_ACCESS_PERM: u64 = 0x00020000;
    const FAN_CLOSE_WRITE: u64 = 0x00000008;
    const FAN_MODIFY: u64 = 0x00000002;

    // Mark flags
    const FAN_MARK_ADD: c_uint = 0x00000001;
    const FAN_MARK_REMOVE: c_uint = 0x00000002;
    const FAN_MARK_MOUNT: c_uint = 0x00000010;
    const FAN_MARK_FILESYSTEM: c_uint = 0x00000100;

    // Response values
    const FAN_ALLOW: u32 = 0x01;
    const FAN_DENY: u32 = 0x02;

    // AT_FDCWD
    const AT_FDCWD: c_int = -100;

    /// Fanotify event metadata
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    struct FanotifyEventMetadata {
        event_len: u32,
        vers: u8,
        reserved: u8,
        metadata_len: u16,
        mask: u64,
        fd: i32,
        pid: i32,
    }

    /// Fanotify response
    #[repr(C)]
    struct FanotifyResponse {
        fd: i32,
        response: u32,
    }

    /// Fanotify monitor configuration
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct FanotifyConfig {
        /// Monitor entire filesystem
        pub monitor_filesystem: bool,

        /// Block execution until scan completes
        pub block_on_exec: bool,

        /// Paths to monitor
        pub watch_paths: Vec<PathBuf>,

        /// Paths to exclude
        pub exclude_paths: Vec<PathBuf>,

        /// File extensions to monitor (empty = all executables)
        pub extensions: Vec<String>,

        /// Maximum file size to scan (bytes)
        pub max_file_size: u64,
    }

    impl Default for FanotifyConfig {
        fn default() -> Self {
            Self {
                monitor_filesystem: false,
                block_on_exec: true,
                watch_paths: vec![
                    PathBuf::from("/home"),
                    PathBuf::from("/tmp"),
                    PathBuf::from("/var/tmp"),
                    PathBuf::from("/opt"),
                    PathBuf::from("/usr/local"),
                ],
                exclude_paths: vec![
                    PathBuf::from("/proc"),
                    PathBuf::from("/sys"),
                    PathBuf::from("/dev"),
                    PathBuf::from("/run"),
                ],
                extensions: vec![
                    "".to_string(), // No extension (ELF binaries)
                    "sh".to_string(),
                    "py".to_string(),
                    "pl".to_string(),
                    "rb".to_string(),
                    "bin".to_string(),
                    "elf".to_string(),
                ],
                max_file_size: 500 * 1024 * 1024, // 500MB
            }
        }
    }

    /// Fanotify-based file monitor
    pub struct FanotifyMonitor {
        fd: RawFd,
        config: FanotifyConfig,
        scanner: Arc<Mutex<FileScanner>>,
        running: Arc<Mutex<bool>>,
        stats: Arc<Mutex<FanotifyStats>>,
    }

    /// Fanotify statistics
    #[derive(Debug, Clone, Default, Serialize, Deserialize)]
    pub struct FanotifyStats {
        pub events_processed: u64,
        pub files_scanned: u64,
        pub threats_blocked: u64,
        pub files_allowed: u64,
        pub scan_errors: u64,
    }

    impl FanotifyMonitor {
        /// Create new fanotify monitor
        pub fn new(config: FanotifyConfig, scanner: Arc<Mutex<FileScanner>>) -> Result<Self, String> {
            // Check if running as root
            if unsafe { libc::geteuid() } != 0 {
                return Err("Fanotify requires root privileges (CAP_SYS_ADMIN)".to_string());
            }

            log::info!("Initializing fanotify monitor");

            // Initialize fanotify
            let flags = if config.block_on_exec {
                FAN_CLASS_PRE_CONTENT | FAN_CLOEXEC | FAN_UNLIMITED_QUEUE | FAN_UNLIMITED_MARKS
            } else {
                FAN_CLASS_CONTENT | FAN_CLOEXEC | FAN_UNLIMITED_QUEUE | FAN_UNLIMITED_MARKS
            };

            let fd = unsafe {
                libc::syscall(
                    libc::SYS_fanotify_init,
                    flags as c_uint,
                    (libc::O_RDONLY | libc::O_LARGEFILE) as c_uint,
                )
            };

            if fd < 0 {
                let err = std::io::Error::last_os_error();
                return Err(format!("Failed to initialize fanotify: {}", err));
            }

            log::info!("âœ… Fanotify initialized (fd: {})", fd);

            Ok(Self {
                fd: fd as RawFd,
                config,
                scanner,
                running: Arc::new(Mutex::new(false)),
                stats: Arc::new(Mutex::new(FanotifyStats::default())),
            })
        }

        /// Start monitoring
        pub fn start(&mut self) -> Result<(), String> {
            log::info!("Starting fanotify monitor");

            // Set running flag
            {
                let mut running = self.running.lock().unwrap();
                *running = true;
            }

            // Add marks for configured paths
            for path in &self.config.watch_paths {
                self.watch_path(path)?;
            }

            // Start event processing thread
            self.start_event_loop();

            log::info!("âœ… Fanotify monitor started");

            Ok(())
        }

        /// Stop monitoring
        pub fn stop(&mut self) {
            log::info!("Stopping fanotify monitor");

            let mut running = self.running.lock().unwrap();
            *running = false;

            // Close fanotify fd
            unsafe {
                libc::close(self.fd);
            }
        }

        /// Add watch for path
        fn watch_path(&self, path: &Path) -> Result<(), String> {
            if !path.exists() {
                log::warn!("Path does not exist: {:?}", path);
                return Ok(());
            }

            let mask = if self.config.block_on_exec {
                FAN_OPEN_EXEC_PERM | FAN_CLOSE_WRITE
            } else {
                FAN_OPEN_EXEC | FAN_CLOSE_WRITE | FAN_MODIFY
            };

            let path_cstr = std::ffi::CString::new(path.to_str().unwrap())
                .map_err(|e| format!("Invalid path: {}", e))?;

            let ret = unsafe {
                libc::syscall(
                    libc::SYS_fanotify_mark,
                    self.fd,
                    FAN_MARK_ADD as c_uint,
                    mask,
                    AT_FDCWD,
                    path_cstr.as_ptr(),
                )
            };

            if ret < 0 {
                let err = std::io::Error::last_os_error();
                return Err(format!("Failed to add mark for {:?}: {}", path, err));
            }

            log::info!("ðŸ‘ï¸  Watching: {:?}", path);

            Ok(())
        }

        /// Start event processing loop
        fn start_event_loop(&self) {
            let fd = self.fd;
            let config = self.config.clone();
            let scanner = self.scanner.clone();
            let running = self.running.clone();
            let stats = self.stats.clone();

            thread::spawn(move || {
                log::info!("ðŸ“¡ Fanotify event loop started");

                let mut buffer = vec![0u8; 4096];

                while *running.lock().unwrap() {
                    // Read events
                    let bytes_read = unsafe {
                        libc::read(
                            fd,
                            buffer.as_mut_ptr() as *mut libc::c_void,
                            buffer.len(),
                        )
                    };

                    if bytes_read <= 0 {
                        if bytes_read < 0 {
                            let err = std::io::Error::last_os_error();
                            if err.kind() != std::io::ErrorKind::WouldBlock {
                                log::error!("Error reading fanotify events: {}", err);
                            }
                        }
                        thread::sleep(Duration::from_millis(100));
                        continue;
                    }

                    // Process events
                    let mut offset = 0;
                    while offset < bytes_read as usize {
                        let metadata = unsafe {
                            &*(buffer.as_ptr().add(offset) as *const FanotifyEventMetadata)
                        };

                        // Update stats
                        {
                            let mut stats_guard = stats.lock().unwrap();
                            stats_guard.events_processed += 1;
                        }

                        // Process event
                        Self::process_event(
                            metadata,
                            &config,
                            &scanner,
                            &stats,
                        );

                        offset += metadata.event_len as usize;
                    }
                }

                log::info!("Fanotify event loop stopped");
            });
        }

        /// Process single fanotify event
        fn process_event(
            metadata: &FanotifyEventMetadata,
            config: &FanotifyConfig,
            scanner: &Arc<Mutex<FileScanner>>,
            stats: &Arc<Mutex<FanotifyStats>>,
        ) {
            // Get file path from fd
            let path = match Self::get_path_from_fd(metadata.fd) {
                Ok(p) => p,
                Err(e) => {
                    log::debug!("Failed to get path: {}", e);
                    Self::respond_allow(metadata.fd);
                    unsafe { libc::close(metadata.fd); }
                    return;
                }
            };

            // Check if should exclude
            if Self::should_exclude(&path, config) {
                Self::respond_allow(metadata.fd);
                unsafe { libc::close(metadata.fd); }
                return;
            }

            // Check file extension
            if !Self::matches_extension(&path, config) {
                Self::respond_allow(metadata.fd);
                unsafe { libc::close(metadata.fd); }
                return;
            }

            log::debug!("ðŸ” Scanning: {:?}", path);

            // Update stats
            {
                let mut stats_guard = stats.lock().unwrap();
                stats_guard.files_scanned += 1;
            }

            // Scan file
            let scan_result = {
                let scanner_guard = scanner.lock().unwrap();
                scanner_guard.scan_file(&path)
            };

            match scan_result {
                Ok(result) => {
                    if result.is_malicious {
                        log::warn!(
                            "ðŸš¨ MALWARE BLOCKED: {:?} (threat: {}, confidence: {:.1}%)",
                            path,
                            result.threat_name.unwrap_or_else(|| "Unknown".to_string()),
                            result.confidence * 100.0
                        );

                        // Block execution
                        Self::respond_deny(metadata.fd);

                        // Update stats
                        let mut stats_guard = stats.lock().unwrap();
                        stats_guard.threats_blocked += 1;
                    } else {
                        log::debug!("âœ… File allowed: {:?}", path);
                        Self::respond_allow(metadata.fd);

                        let mut stats_guard = stats.lock().unwrap();
                        stats_guard.files_allowed += 1;
                    }
                }
                Err(e) => {
                    log::error!("âŒ Scan error for {:?}: {}", path, e);
                    // On error, allow by default (fail-open)
                    Self::respond_allow(metadata.fd);

                    let mut stats_guard = stats.lock().unwrap();
                    stats_guard.scan_errors += 1;
                }
            }

            // Close file descriptor
            unsafe {
                libc::close(metadata.fd);
            }
        }

        /// Get file path from file descriptor
        fn get_path_from_fd(fd: RawFd) -> Result<PathBuf, String> {
            let proc_path = format!("/proc/self/fd/{}", fd);
            std::fs::read_link(&proc_path)
                .map_err(|e| format!("Failed to read link: {}", e))
        }

        /// Check if path should be excluded
        fn should_exclude(path: &Path, config: &FanotifyConfig) -> bool {
            for exclude in &config.exclude_paths {
                if path.starts_with(exclude) {
                    return true;
                }
            }
            false
        }

        /// Check if file matches configured extensions
        fn matches_extension(path: &Path, config: &FanotifyConfig) -> bool {
            if config.extensions.is_empty() {
                return true;
            }

            // Check for no extension (common for ELF binaries)
            if config.extensions.contains(&"".to_string()) {
                if path.extension().is_none() {
                    // Check if it's an executable binary
                    if let Ok(metadata) = std::fs::metadata(path) {
                        use std::os::unix::fs::PermissionsExt;
                        if metadata.permissions().mode() & 0o111 != 0 {
                            return true; // Executable file
                        }
                    }
                }
            }

            // Check extension
            if let Some(ext) = path.extension() {
                let ext_str = ext.to_string_lossy().to_lowercase();
                return config.extensions.contains(&ext_str);
            }

            false
        }

        /// Send allow response
        fn respond_allow(fd: RawFd) {
            let response = FanotifyResponse {
                fd,
                response: FAN_ALLOW,
            };

            unsafe {
                libc::write(
                    fd,
                    &response as *const _ as *const libc::c_void,
                    std::mem::size_of::<FanotifyResponse>(),
                );
            }
        }

        /// Send deny response
        fn respond_deny(fd: RawFd) {
            let response = FanotifyResponse {
                fd,
                response: FAN_DENY,
            };

            unsafe {
                libc::write(
                    fd,
                    &response as *const _ as *const libc::c_void,
                    std::mem::size_of::<FanotifyResponse>(),
                );
            }
        }

        /// Get statistics
        pub fn get_stats(&self) -> FanotifyStats {
            self.stats.lock().unwrap().clone()
        }
    }

    impl Drop for FanotifyMonitor {
        fn drop(&mut self) {
            self.stop();
        }
    }
}

#[cfg(target_os = "windows")]
pub mod windows {
    //! Windows-specific file monitoring
    //!
    //! Uses:
    //! - ReadDirectoryChangesW (userspace)
    //! - Minifilter driver (kernel, planned)

    pub struct WindowsMonitor {
        // TODO: Implement Windows monitoring
    }
}

#[cfg(target_os = "macos")]
pub mod macos {
    //! macOS-specific file monitoring
    //!
    //! Uses:
    //! - FSEvents (userspace)
    //! - Endpoint Security Framework (kernel, requires notarization)

    pub struct MacOSMonitor {
        // TODO: Implement macOS monitoring
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_monitor_config() {
        let config = MonitorConfig::default();
        assert!(config.scan_on_create);
        assert!(config.scan_on_modify);
    }

    #[test]
    fn test_should_exclude() {
        let config = MonitorConfig {
            exclude_paths: vec![PathBuf::from("/home/.cache")],
            ..Default::default()
        };

        assert!(FileMonitor::should_exclude(
            &PathBuf::from("/home/.cache/foo"),
            &config
        ));

        assert!(!FileMonitor::should_exclude(
            &PathBuf::from("/home/user/file.exe"),
            &config
        ));
    }
}
