/*!
 * Real-Time File Monitoring System
 *
 * Monitors file system events for potential malware activity:
 * - File creation, modification, execution
 * - Download completion
 * - Executable access
 *
 * Platform-specific implementations:
 * - Linux: inotify + fanotify (with eBPF planned)
 * - Windows: ReadDirectoryChangesW + kernel filter driver (planned)
 * - macOS: FSEvents + Endpoint Security (planned)
 */

use notify::{Watcher, RecursiveMode, Event, EventKind};
use std::path::{Path, PathBuf};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use crossbeam::channel::{Sender, Receiver};
use chrono::Utc;
use serde::{Serialize, Deserialize};

use crate::malware::scanner::FileScanner;

/// File event types that trigger scanning
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FileEventType {
    Created,
    Modified,
    Executed,
    Downloaded,
    Opened,
}

/// File event metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileEvent {
    pub path: PathBuf,
    pub event_type: FileEventType,
    pub timestamp: i64,
    pub process_name: Option<String>,
    pub process_pid: Option<u32>,
    pub file_size: Option<u64>,
    pub file_hash: Option<String>,
}

/// File monitoring configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitorConfig {
    /// Paths to monitor
    pub watch_paths: Vec<PathBuf>,

    /// Paths to exclude from monitoring
    pub exclude_paths: Vec<PathBuf>,

    /// File extensions to monitor (empty = all)
    pub extensions: Vec<String>,

    /// Scan on file creation
    pub scan_on_create: bool,

    /// Scan on file modification
    pub scan_on_modify: bool,

    /// Scan on file execution
    pub scan_on_execute: bool,

    /// Scan downloads directory
    pub scan_downloads: bool,

    /// Maximum file size to scan (bytes)
    pub max_file_size: u64,
}

impl Default for MonitorConfig {
    fn default() -> Self {
        Self {
            watch_paths: vec![
                PathBuf::from("/home"),      // Linux home directories
                PathBuf::from("/tmp"),        // Temp directory
                PathBuf::from("/var/tmp"),    // Var temp
            ],
            exclude_paths: vec![
                PathBuf::from("/home/.cache"),
                PathBuf::from("/tmp/.X11-unix"),
            ],
            extensions: vec![
                "exe".to_string(), "dll".to_string(), "so".to_string(),
                "sh".to_string(), "py".to_string(), "js".to_string(),
                "elf".to_string(), "bin".to_string(), "app".to_string(),
            ],
            scan_on_create: true,
            scan_on_modify: true,
            scan_on_execute: true,
            scan_downloads: true,
            max_file_size: 500 * 1024 * 1024, // 500MB
        }
    }
}

/// File monitor state
pub struct FileMonitor {
    config: MonitorConfig,
    watcher: Option<notify::RecommendedWatcher>,
    event_tx: Sender<FileEvent>,
    event_rx: Receiver<FileEvent>,
    scanner: Arc<Mutex<FileScanner>>,
    active_scans: Arc<Mutex<HashMap<PathBuf, bool>>>,
}

impl FileMonitor {
    /// Create new file monitor
    pub fn new(config: MonitorConfig, scanner: Arc<Mutex<FileScanner>>) -> Result<Self, String> {
        let (event_tx, event_rx) = crossbeam::channel::unbounded();

        Ok(Self {
            config,
            watcher: None,
            event_tx,
            event_rx,
            scanner,
            active_scans: Arc::new(Mutex::new(HashMap::new())),
        })
    }

    /// Start monitoring file system
    pub fn start(&mut self) -> Result<(), String> {
        log::info!("Starting file system monitor");

        // Create watcher
        let tx = self.event_tx.clone();
        let config = self.config.clone();

        let mut watcher = notify::recommended_watcher(move |res: Result<Event, notify::Error>| {
            match res {
                Ok(event) => {
                    if let Err(e) = Self::handle_notify_event(event, &tx, &config) {
                        log::error!("Error handling file event: {}", e);
                    }
                }
                Err(e) => log::error!("Watch error: {:?}", e),
            }
        }).map_err(|e| format!("Failed to create watcher: {}", e))?;

        // Watch configured paths
        for path in &self.config.watch_paths {
            if path.exists() {
                watcher.watch(path, RecursiveMode::Recursive)
                    .map_err(|e| format!("Failed to watch {:?}: {}", path, e))?;
                log::info!("Watching path: {:?}", path);
            } else {
                log::warn!("Path does not exist: {:?}", path);
            }
        }

        self.watcher = Some(watcher);

        // Start event processing thread
        self.start_event_processor();

        log::info!("File system monitor started");

        Ok(())
    }

    /// Stop monitoring
    pub fn stop(&mut self) {
        log::info!("Stopping file system monitor");
        self.watcher = None;
    }

    /// Handle notify event and convert to FileEvent
    fn handle_notify_event(
        event: Event,
        tx: &Sender<FileEvent>,
        config: &MonitorConfig,
    ) -> Result<(), String> {
        // Filter by event kind
        let event_type = match event.kind {
            EventKind::Create(_) => {
                if !config.scan_on_create {
                    return Ok(());
                }
                FileEventType::Created
            }
            EventKind::Modify(_) => {
                if !config.scan_on_modify {
                    return Ok(());
                }
                FileEventType::Modified
            }
            EventKind::Access(_) => {
                if !config.scan_on_execute {
                    return Ok(());
                }
                FileEventType::Opened
            }
            _ => return Ok(()), // Ignore other events
        };

        // Process each path in the event
        for path in event.paths {
            // Check if path should be excluded
            if Self::should_exclude(&path, config) {
                continue;
            }

            // Check file extension
            if !config.extensions.is_empty() {
                if let Some(ext) = path.extension() {
                    let ext_str = ext.to_string_lossy().to_lowercase();
                    if !config.extensions.contains(&ext_str) {
                        continue;
                    }
                } else {
                    continue; // No extension
                }
            }

            // Check file size
            if let Ok(metadata) = std::fs::metadata(&path) {
                if metadata.len() > config.max_file_size {
                    log::debug!("Skipping large file: {:?} ({}MB)", path, metadata.len() / 1024 / 1024);
                    continue;
                }
            }

            // Create file event
            let file_event = FileEvent {
                path: path.clone(),
                event_type: event_type.clone(),
                timestamp: Utc::now().timestamp(),
                process_name: None, // TODO: Get process info
                process_pid: None,
                file_size: None,
                file_hash: None,
            };

            // Send event for processing
            if let Err(e) = tx.send(file_event) {
                log::error!("Failed to send file event: {}", e);
            }
        }

        Ok(())
    }

    /// Check if path should be excluded
    fn should_exclude(path: &Path, config: &MonitorConfig) -> bool {
        for exclude in &config.exclude_paths {
            if path.starts_with(exclude) {
                return true;
            }
        }
        false
    }

    /// Start event processing thread
    fn start_event_processor(&self) {
        let rx = self.event_rx.clone();
        let scanner = self.scanner.clone();
        let active_scans = self.active_scans.clone();

        std::thread::spawn(move || {
            log::info!("File event processor started");

            while let Ok(event) = rx.recv() {
                // Check if already scanning this file
                {
                    let mut scans = active_scans.lock().unwrap();
                    if scans.contains_key(&event.path) {
                        log::debug!("Scan already in progress: {:?}", event.path);
                        continue;
                    }
                    scans.insert(event.path.clone(), true);
                }

                log::debug!("Processing file event: {:?} ({:?})", event.path, event.event_type);

                // Scan file
                let path = event.path.clone();
                let scanner_clone = scanner.clone();

                std::thread::spawn(move || {
                    let result = {
                        let scanner = scanner_clone.lock().unwrap();
                        scanner.scan_file(&path)
                    };

                    match result {
                        Ok(scan_result) => {
                            if scan_result.is_malicious {
                                log::warn!(
                                    "⚠️  MALWARE DETECTED: {:?} (threat: {}, confidence: {:.1}%)",
                                    path,
                                    scan_result.threat_name.unwrap_or_else(|| "Unknown".to_string()),
                                    scan_result.confidence * 100.0
                                );

                                // TODO: Quarantine file
                                // TODO: Alert user
                            } else {
                                log::debug!("✅ File clean: {:?}", path);
                            }
                        }
                        Err(e) => {
                            log::error!("Failed to scan file {:?}: {}", path, e);
                        }
                    }
                });

                // Remove from active scans
                {
                    let mut scans = active_scans.lock().unwrap();
                    scans.remove(&event.path);
                }
            }

            log::info!("File event processor stopped");
        });
    }

    /// Get monitoring statistics
    pub fn get_stats(&self) -> MonitorStats {
        let active_scans = self.active_scans.lock().unwrap();

        MonitorStats {
            watching_paths: self.config.watch_paths.len(),
            active_scans: active_scans.len(),
            total_events: 0, // TODO: Track this
        }
    }
}

/// Monitoring statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct MonitorStats {
    pub watching_paths: usize,
    pub active_scans: usize,
    pub total_events: u64,
}

#[cfg(target_os = "linux")]
pub mod linux {
    //! Linux-specific file monitoring using fanotify
    //!
    //! Fanotify provides:
    //! - Pre-access notification (block before execution)
    //! - File descriptor access
    //! - Better performance than inotify
    //!
    //! Requires:
    //! - CAP_SYS_ADMIN capability
    //! - Kernel 5.1+ for FAN_OPEN_EXEC_PERM

    use std::path::Path;

    pub struct FanotifyMonitor {
        // TODO: Implement fanotify
    }

    impl FanotifyMonitor {
        pub fn new() -> Result<Self, String> {
            // Check if running as root
            if unsafe { libc::geteuid() } != 0 {
                return Err("Fanotify requires root privileges".to_string());
            }

            // TODO: Initialize fanotify
            Ok(Self {})
        }

        pub fn watch_mount(&self, path: &Path) -> Result<(), String> {
            // TODO: Add fanotify mark for mount point
            Ok(())
        }

        pub fn block_on_execute(&self, enable: bool) -> Result<(), String> {
            // TODO: Enable FAN_OPEN_EXEC_PERM
            Ok(())
        }
    }
}

#[cfg(target_os = "windows")]
pub mod windows {
    //! Windows-specific file monitoring
    //!
    //! Uses:
    //! - ReadDirectoryChangesW (userspace)
    //! - Minifilter driver (kernel, planned)

    pub struct WindowsMonitor {
        // TODO: Implement Windows monitoring
    }
}

#[cfg(target_os = "macos")]
pub mod macos {
    //! macOS-specific file monitoring
    //!
    //! Uses:
    //! - FSEvents (userspace)
    //! - Endpoint Security Framework (kernel, requires notarization)

    pub struct MacOSMonitor {
        // TODO: Implement macOS monitoring
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_monitor_config() {
        let config = MonitorConfig::default();
        assert!(config.scan_on_create);
        assert!(config.scan_on_modify);
    }

    #[test]
    fn test_should_exclude() {
        let config = MonitorConfig {
            exclude_paths: vec![PathBuf::from("/home/.cache")],
            ..Default::default()
        };

        assert!(FileMonitor::should_exclude(
            &PathBuf::from("/home/.cache/foo"),
            &config
        ));

        assert!(!FileMonitor::should_exclude(
            &PathBuf::from("/home/user/file.exe"),
            &config
        ));
    }
}
